# 5.2 条件转移、比较指令和if结构

x86 指令集中没有明确的高级逻辑结构，但是可以通过比较和跳转的组合来实现它们。

执行一个条件语句需要两个步骤：

- 第一步，用 CMP、ADD 或 SUB 等操作来修改 CPU 状态标志位；
- 第二步，用条件跳转指令来测试标志位，并产生一个到新地址的分支。

## CMP 指令

CMP 指令比较整数。字符代码也是整数，因此可以用 CMP 指令。

CMP（比较）指令执行从目的操作数中减去源操作数的隐含减法操作，并且不修改任何操作数：

```CMP destination, source```

### 标志位

当实际的减法发生时，CMP 指令按照计算结果修改溢出、符号、零、进位、辅助进位和奇偶标志位。

如果比较的是两个无符号数，则零标志位和进位标志位表示的两个操作数之间的关系如右表所示：

| CMP结果               | ZF   | CF   |
| --------------------- | ---- | ---- |
| 目的操作数 < 源操作数 | 0    | 1    |
| 目的操作数 > 源操作数 | 0    | 0    |
| 目的操作数 = 源操作数 | 1    | 0    |

如果比较的是两个有符号数，则符号标志位、零标志位和溢出标志位表示的两个操作数之间的关系如右表所示：

| CMP结果               | 标志位  |
| --------------------- | ------- |
| 目的操作数 < 源操作数 | SF ≠ OF |
| 目的操作数 > 源操作数 | SF=OF   |
| 目的操作数 = 源操作数 | ZF=1    |

CMP 指令是创建条件逻辑结构的重要工具。当在条件跳转指令中使用 CMP 时，汇编语言的执行结果就和 IF 语句一样。

## 条件转移指令

下表展示了基于零标志位、进位标志位、溢出标志位、奇偶标志位和符号标志位的跳转。

| 助记符 | 说明       | 标志位/寄存器 | 助记符 | 说明       | 标志位/寄存器 |
| ------ | ---------- | ------------- | ------ | ---------- | ------------- |
| JZ     | 为零跳转   | ZF=1          | JNO    | 无溢出跳转 | OF=0          |
| JNZ    | 非零跳转   | ZF=0          | JS     | 有符号跳转 | SF=1          |
| JC     | 进位跳转   | CF=1          | JNS    | 无符号跳转 | SF=0          |
| JNC    | 无进位跳转 | CF=0          | JP     | 偶校验跳转 | PF=1          |
| JO     | 溢出跳转   | OF=1          | JNP    | 奇校验跳转 | PF=0          |

### 相等性的比较

下表列出了基于相等性评估的跳转指令。有些情况下，进行比较的是两个操作数；其他情况下，则是基于 CX、ECX 或 RCX 的值进行跳转。表中符号 leftOp 和 rightOp 分别指的是 CMP 指令中的左（目的）操作数和右（源）操 作数：

| 助记符 | 说明                          |
| ------ | ----------------------------- |
| JE     | 相等跳转 (leftOp=rightOp)     |
| JNE    | 不相等跳转 (leftOp M rightOp) |
| JCXZ   | CX=0 跳转                     |
| JECXZ  | ECX=0 跳转                    |
| JRCXZ  | RCX=0 跳转（64 位模式）       |

### 无符号数比较

基于无符号数比较的跳转如下表所示。操作数的名称反映了表达式中操作数的顺序（比如 leftOp < rightOp）。下表中的跳转仅在比较无符号数值时才有意义。有符号操作数使用不同的跳转指令。

| 助记符 | 说明                                  | 助记符 | 说明                                  |
| ------ | ------------------------------------- | ------ | ------------------------------------- |
| JA     | 大于跳转（若 leftOp > rightOp）       | JB     | 小于跳转（若 leftOp < rightOp）       |
| JNBE   | 不小于或等于跳转（与 JA 相同）        | JNAE   | 不大于或等于跳转（与 JB 相同）        |
| JAE    | 大于或等于跳转（若 leftOp ≥ rightOp） | JBE    | 小于或等于跳转（若 leftOp ≤ rightOp） |
| JNB    | 不小于跳转（与 JAE 相同）             | JNA    | 不大于跳转（与 JBE 相同）             |

### 有符号数比较

下表列岀了基于有符号数比较的跳转。下面的指令序列展示了两个有符号数值的比较：

| 助记符 | 说明                                  | 助记符 | 说明                                  |
| ------ | ------------------------------------- | ------ | ------------------------------------- |
| JG     | 大于跳转（若 leftOp > rightOp）       | JL     | 小于跳转（若 leftOp < rightOp）       |
| JNLE   | 不小于或等于跳转（与 JG 相同）        | JNGE   | 不大于或等于跳转（与 JL 相同）        |
| JGE    | 大于或等于跳转（若 leftOp ≥ rightOp） | JLE    | 小于或等于跳转（若 leftOp ≤ rightOp） |
| JNL    | 不小于跳转（与 JGE 相同）             | JNG    | 不大于跳转（与 JLE 相同）             |

## 使用汇编语言实现if语句

IF 结构包含一个布尔表达式，其后有两个语句列表：一个是当表达式为真时执行，另一个是当表达式为假时执行：

```
if( boolean-expression )
	statement-list-1
else
	statement-list-2
```

结构中的 else 部分是可选的。在汇编语言中，则是用多个步骤来实现这种结构的。首先，对布尔表达式求值，这样一来某个 CPU 状态标志位会受到影响。然后，根据相关 CPU 状态标志位的值，构建一系列跳转把控制传递给两个语句列表。

【示例 1】下面的 C++ 代码中，如果 op1 等于 op2，则执行两条赋值语句：

```cpp
if( op1 = op2 )
{
    X = 1;
    Y = 2;
}
```

在汇编语言中，这种 IF 语句转换为条件跳转和 CMP 指令。由于 op1 和 op2 都是内存操作数（变量），因此，在执行 CMP 之前，要将其中的一个操作数送入寄存器。

下面实现 IF 语句的程序是高效的，当逻辑表达式为真时，它允许代码“通过”直达两条期望被执行的 MOV 指令：

```assembly
	mov eax, op1
	cmp eax, op2	; op1 == op2?
	jne L1			; 否：跳过后续指令
	mov X, 1		; 是：X, Y 赋值
	mov Y, 2
L1:
```

如果用 JE 来实现 == 运算符，生成的代码就没有那么紧凑了（6 条指令，而非 5 条指令）：

```assembly
	mov eax, op1
	cmp eax, op2	; op1 == op2?
	je L1			; 是：跳转到 L1
	jmp L2			; 否：跳过赋值语句
L1:	
	mov X, 1		; X, Y 赋值
	mov Y, 2
L2:
```

从上面的例子可以看出，相同的条件结构在汇编语言中有多种实现方法。上面给出的编译代码示例只代表一种假想的编译器可能产生的结果。

