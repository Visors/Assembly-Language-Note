# 1.4 二进制补码数的加减法

> *从本节开始，我将摒弃之前过细描述的臃肿感，略过人人皆知的定义，采用更加精炼的语言，减少在书本重现上浪费的时间，转而让我从每日的忙碌中解放出来，可以更细心的阅读中英教材，专注书本知识的注意点，以及我个人学习经验对之的拓展，真正使复杂的问题简单化，使抽象的东西形象化。*

---------------------------------

## 两种重要情况

有符号数用二进制补码形式表示，但二进制补码数也可看作无符号数，所以有符号数相加并不完全等于补码数相加。

在二进制补码数的加减法中，我们关注计算中的两种情况：

1. 向符号位的进位
2. 符号位进位输出

### 向符号位的进位

举一例说明：

  0100 1000 0011 1111

+0110 0100 0101 1010

=1010 1100 1001 1001

可以看到，当$$483F$$与$$645A$$相加后，得到的结果$$AC99$$超过了我们说的字长的二进制补码的分界线$$8000$$，抑或是说符号位由$$0$$变为$$1$$。我们称这种情况为向符号位的进位。

### 符号位进位输出

再举一例：

​    1110 1001 1111 1111

  +1000 1100 1111 0000

=10111 0110 1110 1111

可以看到$$E9FF$$和$$8CF0$$相加后，得到的结果$$176EF$$超过了字长的存储位数限制。实际计算机存储中，该结果会被强行截断成字长（截去超出范围）。在这个例子中，实际结果为$$76EF$$。

## 溢出

当加法运算中发生**溢出overflow**时，得到的结果存在错误。我们可以人为判断溢出是否发生，计算机硬件也可以判断。判断溢出与否的方法就跟上述两种情况有关。事实上，溢出并不如其字面上那样，“是单纯的超过数据范围”，而应该是如下情况：

| 向符号位的进位 | 符号位进位输出 | 溢出 |
| :------------: | :------------: | :--: |
|       0        |       0        |  0   |
|       0        |       1        |  1   |
|       1        |       0        |  1   |
|       1        |       1        |  0   |

这张类似真值表的情况表给出了判断溢出是否发生的简单方法。

## 二进制减法

将减法看作加上对应数的负数，即加负数的补码即可。