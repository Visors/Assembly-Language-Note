# 1.3 有符号整数的二进制补码表示

前面小节已介绍过二进制和ASCII，如果要在计算机中表示数，可以对应的用到这两种表示方法：

* **ASCII表示** 把数字看成字符，拆成一个个字符存在一起
* **二进制表示** 进制转换

这两种表示方法在表示时有两点问题值得注意：

1. 表示数的有效位是有限的
2. 如何表示负数并不明确

---------------------------------------------

## ASCII表示

常见ASCII码为0~127，正好可以用7位表示。8位1字节，附加位（左侧或最高位）设为0即可。

如果要表示负数，负号（减号）的ASCII为2D，用一位记下即可。

$$-817=2D~38~31~37$$

解决第一个问题的方法是固定字节长度，位数不足时补前导0.

也可以用长度可变的字节数，但须规定以非数字字符结尾（用以分割）。

----------------------------------

## 二进制表示

将十进制转化为二进制存储。

解决第一个问题同样是定长补前导0，下面这个例子是2字节（16位）定长表示（___1字节=8位 1字=16位___）。

> $$697_{10}=1010111001_2=0000001010111001_2=02B9_{16}$$

这样便可以很好的表示非负数和无符号数，但负号是符号不是数值，不能拆解在二进制表示中。

当然你也可以说负号ASCII码$$2D_{16}$$可以拆成$$101101_2$$，但若真这样做，负号将会占用6位，考虑到整数的普遍性，我们在对每一个数存储时都要考虑其成为负数的可能性，那么___每个数都要预留一个“负数位”，这样会造成巨大的空间浪费，是极其不成熟的___。我们采用“二进制补码表示法”解决这个问题。

----------------------

## 二进制补码表示

规定二进制数最左边一位为**符号位**。

> $$0111111111111111_2=7FFF_{16}=32767_{10}$$

最左边的符号位被置为0，表示这个数是正数。

但这并不意味着负数的符号位为1，然后其他部分与之完全相同（这种表示方法叫做**原码**）。

___表示负数惯用的做法___是对其**取补**：

对于定长二进制数，用1后跟二进制位数个0表示的二进制数减去___无符号部分___。

下面这个例子展示了十进制负数取补的过程。

$$-76_{10}=10000_{16}-76_{10}=10000_{16}-004C_{16}=FFB4_{16}$$

> 减法部分参照竖式运算
>
> 减去无符号部分可以视为减绝对值
>

单字长为16位，所以用17位$$10000000000000000_2=10000_{16}=2^{16}$$减无符号部分取补。我们称$$FFB4$$为$$-76$$的**补码**。___非负数的补码只需在前面加前导0占位___。

## 补码的基本性质

### 补码表示数的范围

由于我们规定了符号位，所以以单字长二进制数为例，最大正整数为$$0111111111111111=1000000000000000-1=2^{15}-1$$

可以推广一下，即对于$$N$$位二进制数，最大正整数为$$2^{N-1}-1$$.

自然，我们也想知道最小负整数，我们可以从将二进制补码还原为负数这一角度入手。

根据符号位的定义，第一位为1时为负数，换言之，负数的补码范围为$$1000000000000000\sim1111111111111111$$

分析原操作，设该负数为$$-x$$，长度为$$N$$位（其中有一个符号位，故有效位数实际上是$$N-1$$），补码为$$y$$，那么有$$2^N-x=y$$，在$$y$$已知的情况下：

> $$2^N-x=y$$
> 
> $$y-2^N=-x$$
> 
> $$x=2^N-y$$

由负数补码范围知$$2^{N-1}\leq y<2^N$$，那么$$y$$越小，$$2^N-y$$就越大，$$x$$就越大，$$-x$$就越小

即$$-x$$在$$y=2^{N-1}$$时取得最小值，最小为$$-2^{N-1}$$

也就是说

$$N$$___位表示的数的范围为___$$-2^{N-1}\sim2^{N-1}-1$$

### 补码的还原

$$2^{N-1}-x=y$$

$$2^{N-1}-y=2^{N-1}-(2^{N-1}-x)=x$$

也就是说，对一个数二次取补会得到它的本身。

但需要注意，___取补与表示为补码为不同的操作___，事实上：

如果原数是一个非负数，当我们知道它的补码表示（等于原数）时，再表示出这个补码的补码，仍然是原数，因为这个过程中数都为非负数，非负数的补码操作只是补足前导0.

如果原数是一个负数，当我们知道它的补码表示（对无符号部分求补）时，再表示出这个补码的补码，会得到原数的无符号部分。

所以还原补码的正确操作应该是先判断补码的符号，确定原数是不是负数后，再对照上面的规则求出。

> 一个简单的判断符号的方法是，如果这个补码大于该长度二进制数表示的一半，那么原数是负数；反之为非负数。对于字长的二进制补码，”一半“指的是8000；对于字节的二进制补码，”一半“指的是80.

由此结论，我们还可以简化前面补码表示数的范围的推理过程。

## 取补的另一种方法

由于二进制太长书写不变，此前我们都是用十六进制缩写二进制，这种表示下，做十六进制减法效率上很高。实际上，我们还有另一种取补方法：

__原码非符号位按位取反+1__

前面的例子我们已经知道$$-76$$表示成字节的二进制补码是$$B4_{16}$$

我们尝试一下按位取反

> 按位取反既是对每位取反，1成0，0成1.这里接用很多高级语言按位取反运算符~表示

$$-76=11001100_2$$

$$\sim76=10110011_2$$ 再加上1，得到的结果便是

$$10110100_2=B4_{16}$$

与前面的结果一致。

