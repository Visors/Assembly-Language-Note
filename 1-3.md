# 1.3 有符号整数的二进制补码表示

前面小节已介绍过二进制和ASCII，如果要在计算机中表示数，可以对应的用到这两种表示方法：

* **ASCII表示** 把数字看成字符，拆成一个个字符存在一起
* **二进制表示** 进制转换

这两种表示方法在表示时有两点问题值得注意：

1. 表示数的有效位是有限的
2. 如何表示负数并不明确

---------------------------------------------

## ASCII表示

常见ASCII码为0~127，正好可以用7位表示。8位1字节，附加位（左侧或最高位）设为0即可。

如果要表示负数，负号（减号）的ASCII为2D，用一位记下即可。

> $-817=2D~38~31~37$

解决第一个问题的方法是固定字节长度，位数不足时补前导0.

也可以用长度可变的字节数，但须规定以非数字字符结尾（用以分割）。

----------------------------------

## 二进制表示

将十进制转化为二进制存储。

解决第一个问题同样是定长补前导0，下面这个例子是2字节（16位）定长表示（==1字节=8位 1字=16位==）。

> $697_{10}=1010111001_2=0000001010111001_2=02B9_{16}$

这样便可以很好的表示非负数和无符号数，但负号是符号不是数值，不能拆解在二进制表示中。

> 当然你也可以说负号ASCII码$2D_{16}$可以拆成$101101_2$，但若真这样做，负号将会占用6位，考虑到整数的普遍性，我们在对每一个数存储时都要考虑其成为负数的可能性，那么==每个数都要预留一个“负数位”，这样会造成巨大的空间浪费，是极其不成熟的==。我们采用“二进制补码表示法”解决这个问题。

----------------------

## 二进制补码表示

规定二进制数最左边一位为符号位。

> $0111111111111111_2=7FFF_{16}=32767_{10}$

最左边的符号位被置为0，表示这个数是正数。

但这并不意味着负数的符号位为1，其他部分与之完全相同（虽然这样看上去很科学便捷，但是会破坏加法操作）。

正规的做法是**取补**：

对于定长二进制数，用该长度二进制数表示的最大值+1（即超一位最小值）减去==无符号部分==。对于单字长二进制数：

> $-76_{10}=10000_{16}-76_{10}=10000_{16}-4C_{16}=FFB4_{16}$
>
> 减法部分参照竖式运算
>
> 减去无符号部分可以视为减绝对值

单字长为16位，所以用17位$10000000000000000_2=10000_{16}=2^{16}$减无符号部分取补。我们称$FFB4$为$-76$的**补码**。

由于我们规定了符号位，所以以单字长二进制数为例，最大正整数为$0111111111111111=1000000000000000-1=2^{15}-1$

可以推广一下，即对于$N$位二进制数，最大正整数为$2^{N-1}-1$.

自然，我们也想知道最小负整数，我们可以从将二进制补码还原为负数这一角度入手。

分析原操作，设该负数为$-x$，长度为$N$位（其中有一个符号位，故有效位数实际上是$N-1$），补码为$y$，那么有$2^{N-1}-x=y$，在$y$已知的情况下：

> $2^{N-1}-x=y$
>
> $y-2^{N-1}=-x$
>
> $x=2^{N-1}-y$
>
> 显然$y<2^{N-1}$，那么$y$越小，$2^{N-1}-y$就越大，$x$就越大，$-x$就越小
>
> 即$-x$最小为$-2^{N-1}$
>
> 补码为$0$，虽然这意味着$x=2^{N-1}$，与前面$x\leq2^{N-1}-1$的结论不符，但其实二者不相干，你不能否认$2^{N-1}$在数学上的存在，它的补码就是$0$.

也就是说

> ==$N$位表示的数的范围为$-2^{N-1}\sim2^{N-1}-1$==

此外易知对一个数的补码求补会得到它的无符号部分。

> $2^{N-1}-x=y$
>
> $2^{N-1}-y=2^{N-1}-(2^{N-1}-x)=x$

