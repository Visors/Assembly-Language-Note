# 4.3 乘法指令

## MUL 指令

乘数和被乘数的大小必须保持一致，乘积的大小则是它们的一倍。这三种类型都可以使用寄存器和内存操作数，但不能使用立即数：

```assembly
MUL reg/mem8
MUL reg/meml6
MUL reg/mem32
```

MUL 指令中的单操作数是乘数。下表按照乘数的大小，列出了默认的被乘数和乘积。由于目的操作数是被乘数和乘数大小的两倍，因此不会发生溢岀。

| 被乘数 | 乘数      | 乘积    |
| ------ | --------- | ------- |
| AL     | reg/mem8  | AX      |
| AX     | reg/mem16 | DX:AX   |
| EAX    | reg/mem32 | EDX:EAX |

如果乘积的高半部分不为零，则 MUL 会把进位标志位和溢出标志位置 1。因为进位标志位常常用于无符号数的算术运算，在此我们也主要说明这种情况。例如，当 AX 乘以一个 16 位操作数时，乘积存放在 DX 和 AX 寄存器对中。其中，乘积的高 16 位存放在 DX，低 16 位存放在 AX。如果 DX 不等于零，则进位标志位置 1，这就意味着隐含的目的操作数的低半部分容纳不了整个乘积。

有个很好的理由要求在执行 MUL 后检查进位标志位，即，确认忽略乘积的高半部分是否安全。

```assembly
.data
val1 WORD 2000h
val2 WORD 0l00h
.code
mov ax, val1           ; AX = 2000h
mul val2               ; DX:AX = 00200000h, CF = 1
```

## IMUL 指令

IMUL（有符号数乘法）指令执行有符号整数乘法。与 MUL 指令不同，IMUL 会保留乘 积的符号，实现的方法是，将乘积低半部分的最高位符号扩展到高半部分。

### 单操作数格式

单操作数格式将乘积存放在 AX、DX:AX 或 EDX:EAX 中：

```assembly
IMUL reg/mem8  ; AX = AL * reg/mem8
IMUL reg/meml6  ; DX:AX = AX * reg/meml6
IMUL reg/mem32  ; EDX:EAX = EAX * reg/mem32
```

和 MUL 指令一样，其乘积的存储大小使得溢出不会发生。同时，如果乘积的高半部分不是其低半部分的符号扩展，则进位标志位和溢出标志位置 1。利用这个特点可以决定是否忽略乘积的高半部分。

###  双操作数格式（32位模式）

32 位模式中的双操作数 IMUL 指令把乘积存放在第一个操作数中，这个操作数必须是寄存器。第二个操作数（乘数）可以是寄存器、内存操作数和立 即数。16位格式如下所示：

```assembly
IMUL regl6, reg/meml6
IMUL regl6, imm8
IMUL regl6, imml6
```

32 位操作数类型如下所示，乘数可以是 32 位寄存器、32 位内存操作数或立即数（8 位 或 32 位）：

```assembly
IMUL reg32, reg/mem32
IMUL reg32, inun8
IMUL reg32, imm32
```

双操作数格式会按照目的操作数的大小来截取乘积。如果被丢弃的是有效位，则溢出标志位和进位标志位置 1。因此，在执行了有两个操作数的 IMUL 操作后，必须检查这些标志位中的一个。

### 三操作数格式

32 位模式下的三操作数格式将乘积保存在第一个操作数中。第二个操作数可以是 16 位寄存器或内存操作数，它与第三个操作数相乘，该操作数是一个8位或16 位立即数：

```assembly
IMUL regl6, reg/meml6,imm8
IMUL regl6, reg/meml6, iirrnl6
```

而 32 位寄存器或内存操作数可以与 8 位或 32 位立即数相乘：

```assembly
IMUL reg32, reg/mem32, imm8
IMUL reg32, reg/mem32, imm32
```

IMUL 执行时，若乘积有效位被丢弃，则溢出标志位和进位标志位置 1。因此，在执行了有三个操作数的 IMUL 操作后，必须检查这些标志位中的一个。