# 6.2 过程体、调用和返回

## 过程与函数的关系

如果大家已经学过了高级编程语言，那么就会知道将程序分割为子过程（subroutine）是多么有用。一个复杂的问题常常要分解为相互独立的任务，这样才易于被理解、实现以及有效地测试。

在汇编语言中，通常用术语过程（procedure）来指代子程序。在其他语言中，子程序也被称为方法或函数。

就面向对象编程而言，单个类中的函数或方法大致相当于封装在一个汇编语言模块中的过程和数据集合。汇编语言出现的时间远早于面向对象编程，因此它不具备面向对象编程中的形式化结构。汇编程序员必须在程序中实现自己的形式化结构。

## 定义过程

过程可以非正式地定义为：由返回语句结束的已命名的语句块。过程用 PROC 和 ENDP 伪指令来定义，并且必须为其分配一个名字（有效标识符）。到目前为止，所有编写的程序都包含了一个名为 main 的过程，例如：

```assembly
main PROC
	;过程内容
main ENDP
```

当在程序启动过程之外创建一个过程时，就用 RET 指令来结束它。RET 强制 CPU 返回到该过程被调用的位置：

```assembly
sample PROC
	;过程内容
	ret
sample ENDP
```

## 过程中的标号

默认情况下，标号只在其被定义的过程中可见。这个规则常常影响到跳转和循环指令。在下面的例子中，名为 Destination 的标号必须与 JMP 指令位于同一个过程中：

```jmp Destination```

解决这个限制的方法是定义全局标号，即在名字后面加双冒号 (::)。

```Destination::```

就程序设计而言，跳转或循环到当前过程之外不是个好主意。过程用自动方式返回并调整运行时堆栈。如果直接跳出一个过程，则运行时堆栈很容易被损坏。

## 示例：三个整数求和

现在创建一个名为 SumOf 的过程计算三个 32 位整数之和。**假设在过程调用之前，整数已经分配给 EAX、EBX 和 ECX**。过程用 EAX 返回和数：

```assembly
SumOf PROC NEAR32	; 课堂上我们这么写
	add eax,ebx
	add eax,ecx
	ret
SumOf ENDP
```

## CALL RET

CALL 指令调用一个过程，指挥处理器从新的内存地址开始执行。过程使用 RET（从过程返回）指令将处理器转回到该过程被调用的程序点上。

从物理上来说，**CALL 指令将其返回地址压入堆栈，再把被调用过程的地址复制到指令指针寄存器**。当过程准备返回时，它的 **RET 指令从堆栈把返回地址弹回到指令指针寄存器**。32 位模式下，CPU 执行的指令由 EIP（指令指针寄存器）在内存中指岀。16 位模式下，由 IP 指出指令。

## 调用和返回示例

假设在 main 过程中，CALL 指令位于偏移量为 0000 0020 处。通常，这条指令需要 5 个字节的机器码，因此，下一条语句（本例中为一条 MOV 指令）就位于偏移量为 0000 0025 处：

```assembly
main PROC
00000020 call MySub
00000025 mov eax,ebx
```

然后，假设 MySub 过程中第一条可执行指令位于偏移量 0000 0040 处：

```assembly
MySub PROC
00000040 mov eaxz edx
	...
	...
	ret
MySub ENDP
```

当 CALL 指令执行时如下图所示，调用之后的地址（0000 0025）被压入堆栈，MySub 的地址加载到 EIP。

![执行CALL指令](http://c.biancheng.net/uploads/allimg/190505/4-1Z5051K14A60.gif)

执行 MySub 中的全部指令直到 RET 指令。当执行 RET 指令时，ESP 指向的堆栈数值被弹岀到 EIP（如下图所示，步骤 1）。在步骤 2 中，ESP 的数值增加，从而指向堆栈中的前一个值（步骤 2）。

![执行RET指令](http://c.biancheng.net/uploads/allimg/190505/4-1Z5051K214956.gif)

```ret count ```

如果你见到上面 ret 一个操作数的指令，不必惊慌，他是先返回过程地址，再 pop count 个字节。

