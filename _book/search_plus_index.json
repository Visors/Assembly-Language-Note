{"./":{"url":"./","title":"前言","keywords":"","body":"Introduction 《80x86汇编语言与计算机体系结构》学习笔记 written by Visors QQ:416815311 Mail:visors@scuec.edu.cn 欢迎在评论区指出问题，讨论学术🤭 Written by Visors all right reserved，powered by Gitbook本文档更新于： 2019-09-02 22:28 "},"1.html":{"url":"1.html","title":"1 计算机中数的表示","keywords":"","body":"1 计算机中数的表示 Written by Visors all right reserved，powered by Gitbook本文档更新于： 2019-08-26 23:12 "},"1-1.html":{"url":"1-1.html","title":"1.1 二进制和十六进制数","keywords":"","body":"1.1 二进制和十六进制数 本节给出了计算机存储中二进制数和十六进制数之间的关系。 日常生活中我们用十进制来表示数，逢十进一。 计算机由于其典型的开关式设计，无法直接采用十进制存储，用的是二进制01式的存储（0关1开）。 二进制权值与十进制不同： 11010=1∗104+1∗103+0∗102+1∗101+0∗10011010=1*10^4+1*10^3+0*10^2+1*10^1+0*10^011010=1∗10​4​​+1∗10​3​​+0∗10​2​​+1∗10​1​​+0∗10​0​​ 110102=1∗24+1∗23+0∗22+1∗21+0∗20=2611010_2=1*2^4+1*2^3+0*2^2+1*2^1+0*2^0=2611010​2​​=1∗2​4​​+1∗2​3​​+0∗2​2​​+1∗2​1​​+0∗2​0​​=26 究其根本原因是系数相同而权值不同。 同理十六进制即权值为16. 十进制 十六进制 二进制 0 0 0 1 1 1 2 2 10 3 3 11 4 4 100 5 5 101 6 6 110 7 7 111 8 8 1000 9 9 1001 10 A 1010 11 B 1010 12 C 1100 13 D 1101 14 E 1110 15 F 1111 可以发现，如果将不足4位的二进制数的前置空位补上0，那么可以认为每四位二进制数对应一个十六进制数。 同理八进制数可用三位二进制数表示，三位十六进制数可用四位八进制数表示。 进制转换高中数学讲过。 十进制转N进制——除N取余法 N进制转十进制——按位展开法 Written by Visors all right reserved，powered by Gitbook本文档更新于： 2019-09-02 14:23 "},"1-2.html":{"url":"1-2.html","title":"1.2 字符编码","keywords":"","body":"1.2 字符编码 计算机无法直接存储字符，故而用特定数值来表示各种字符，最常见的表示规则是美国信息交换标准代码ASCII，它建立了字符与数值间的映射关系。 ASCII码表 表中0016∼1F1600_{16}\\sim1F_{16}00​16​​∼1F​16​​比较特殊，他们不是常规意义上的字符（打印输出字符），他们是控制字符。例如特殊服务控制ESC、回车CR、换行LF等。 Written by Visors all right reserved，powered by Gitbook本文档更新于： 2019-09-02 16:57 "},"1-3.html":{"url":"1-3.html","title":"1.3 有符号整数的二进制补码表示","keywords":"","body":"1.3 有符号整数的二进制补码表示 前面小节已介绍过二进制和ASCII，如果要在计算机中表示数，可以对应的用到这两种表示方法： ASCII表示 把数字看成字符，拆成一个个字符存在一起 二进制表示 进制转换 这两种表示方法在表示时有两点问题值得注意： 表示数的有效位是有限的 如何表示负数并不明确 ASCII表示 常见ASCII码为0~127，正好可以用7位表示。8位1字节，附加位（左侧或最高位）设为0即可。 如果要表示负数，负号（减号）的ASCII为2D，用一位记下即可。 −817=2D 38 31 37-817=2D~38~31~37−817=2D 38 31 37 解决第一个问题的方法是固定字节长度，位数不足时补前导0. 也可以用长度可变的字节数，但须规定以非数字字符结尾（用以分割）。 二进制表示 将十进制转化为二进制存储。 解决第一个问题同样是定长补前导0，下面这个例子是2字节（16位）定长表示（1字节=8位 1字=16位）。 69710=10101110012=00000010101110012=02B916697_{10}=1010111001_2=0000001010111001_2=02B9_{16}697​10​​=1010111001​2​​=0000001010111001​2​​=02B9​16​​ 这样便可以很好的表示非负数和无符号数，但负号是符号不是数值，不能拆解在二进制表示中。 当然你也可以说负号ASCII码2D162D_{16}2D​16​​可以拆成1011012101101_2101101​2​​，但若真这样做，负号将会占用6位，考虑到整数的普遍性，我们在对每一个数存储时都要考虑其成为负数的可能性，那么每个数都要预留一个“负数位”，这样会造成巨大的空间浪费，是极其不成熟的。我们采用“二进制补码表示法”解决这个问题。 二进制补码表示 规定二进制数最左边一位为符号位。 01111111111111112=7FFF16=32767100111111111111111_2=7FFF_{16}=32767_{10}0111111111111111​2​​=7FFF​16​​=32767​10​​ 最左边的符号位被置为0，表示这个数是正数。 但这并不意味着负数的符号位为1，然后其他部分与之完全相同（这种表示方法叫做原码）。 表示负数惯用的做法是对其取补： 对于定长二进制数，用1后跟二进制位数个0表示的二进制数减去无符号部分。 下面这个例子展示了十进制负数取补的过程。 −7610=1000016−7610=1000016−004C16=FFB416-76_{10}=10000_{16}-76_{10}=10000_{16}-004C_{16}=FFB4_{16}−76​10​​=10000​16​​−76​10​​=10000​16​​−004C​16​​=FFB4​16​​ 减法部分参照竖式运算 减去无符号部分可以视为减绝对值 单字长为16位，所以用17位100000000000000002=1000016=21610000000000000000_2=10000_{16}=2^{16}10000000000000000​2​​=10000​16​​=2​16​​减无符号部分取补。我们称FFB4FFB4FFB4为−76-76−76的补码。非负数的补码只需在前面加前导0占位。 补码的基本性质 补码表示数的范围 由于我们规定了符号位，所以以单字长二进制数为例，最大正整数为0111111111111111=1000000000000000−1=215−10111111111111111=1000000000000000-1=2^{15}-10111111111111111=1000000000000000−1=2​15​​−1 可以推广一下，即对于NNN位二进制数，最大正整数为2N−1−12^{N-1}-12​N−1​​−1. 自然，我们也想知道最小负整数，我们可以从将二进制补码还原为负数这一角度入手。 根据符号位的定义，第一位为1时为负数，换言之，负数的补码范围为1000000000000000∼11111111111111111000000000000000\\sim11111111111111111000000000000000∼1111111111111111 分析原操作，设该负数为−x-x−x，长度为NNN位（其中有一个符号位，故有效位数实际上是N−1N-1N−1），补码为yyy，那么有2N−x=y2^N-x=y2​N​​−x=y，在yyy已知的情况下： 2N−x=y2^N-x=y2​N​​−x=y y−2N=−xy-2^N=-xy−2​N​​=−x x=2N−yx=2^N-yx=2​N​​−y 由负数补码范围知2N−1≤y2N2^{N-1}\\leq y2​N−1​​≤y2​N​​，那么yyy越小，2N−y2^N-y2​N​​−y就越大，xxx就越大，−x-x−x就越小 即−x-x−x在y=2N−1y=2^{N-1}y=2​N−1​​时取得最小值，最小为−2N−1-2^{N-1}−2​N−1​​ 也就是说 NNN位表示的数的范围为−2N−1∼2N−1−1-2^{N-1}\\sim2^{N-1}-1−2​N−1​​∼2​N−1​​−1 补码的还原 2N−1−x=y2^{N-1}-x=y2​N−1​​−x=y 2N−1−y=2N−1−(2N−1−x)=x2^{N-1}-y=2^{N-1}-(2^{N-1}-x)=x2​N−1​​−y=2​N−1​​−(2​N−1​​−x)=x 也就是说，对一个数二次取补会得到它的本身。 但需要注意，取补与表示为补码为不同的操作，事实上： 如果原数是一个非负数，当我们知道它的补码表示（等于原数）时，再表示出这个补码的补码，仍然是原数，因为这个过程中数都为非负数，非负数的补码操作只是补足前导0. 如果原数是一个负数，当我们知道它的补码表示（对无符号部分求补）时，再表示出这个补码的补码，会得到原数的无符号部分。 所以还原补码的正确操作应该是先判断补码的符号，确定原数是不是负数后，再对照上面的规则求出。 一个简单的判断符号的方法是，如果这个补码大于该长度二进制数表示的一半，那么原数是负数；反之为非负数。对于字长的二进制补码，”一半“指的是8000；对于字节的二进制补码，”一半“指的是80. 由此结论，我们还可以简化前面补码表示数的范围的推理过程。 取补的另一种方法 由于二进制太长书写不变，此前我们都是用十六进制缩写二进制，这种表示下，做十六进制减法效率上很高。实际上，我们还有另一种取补方法： 原码非符号位按位取反+1 前面的例子我们已经知道−76-76−76表示成字节的二进制补码是B416B4_{16}B4​16​​ 我们尝试一下按位取反 按位取反既是对每位取反，1成0，0成1.这里接用很多高级语言按位取反运算符~表示 −76=110011002-76=11001100_2−76=11001100​2​​ ∼76=101100112\\sim76=10110011_2∼76=10110011​2​​ 再加上1，得到的结果便是 101101002=B41610110100_2=B4_{16}10110100​2​​=B4​16​​ 与前面的结果一致。 Written by Visors all right reserved，powered by Gitbook本文档更新于： 2019-09-02 23:02 "},"1-4.html":{"url":"1-4.html","title":"1.4 二进制补码数的加减法","keywords":"","body":"1.4 二进制补码数的加减法 无符号数的二进制加法 理同竖式运算，逐位相加，逢2进1，可列出此表： 0+0=0 0+1=1 1+0=1 1+1=10 比如$0A07$与$01D3$相加： 0A07 +01D3​ =0BDA 结果与转换为十进制后的2567+467=30342567+467=30342567+467=3034相同（3034=0BDA163034=0BDA_{16}3034=0BDA​16​​）。 当然这只是一般情况，可能遇到两个大数相加，导致最高位进位，这时会发生溢出overflow现象，所有超过约定存储位数的数字会丢失，例如： 11111111+00000001=10000000011111111+00000001=10000000011111111+00000001=100000000 如果约定存储位数为8位，那么实际取得的结果只有000000000000000000000000 有符号数的二进制加法 Written by Visors all right reserved，powered by Gitbook本文档更新于： 2019-09-02 22:44 "}}