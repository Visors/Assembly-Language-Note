{"./":{"url":"./","title":"前言","keywords":"","body":"Introduction 《80x86汇编语言与计算机体系结构》学习笔记 written by Visors QQ:416815311 Mail:visors@scuec.edu.cn 欢迎在评论区指出问题，讨论学术🤭 如果你的电脑上没有显示disqus，可以移步讨论区 Written by Visors all right reserved，powered by Gitbook本文档更新于： 2019-09-05 18:48 "},"1.html":{"url":"1.html","title":"1 计算机中数的表示","keywords":"","body":"1 计算机中数的表示 本章主要介绍了计算机的存储方式，以及数的表示和运算。是基础中的基础，后面的很多章节都基于这节的内容。 Written by Visors all right reserved，powered by Gitbook本文档更新于： 2019-09-16 23:43 "},"1-1.html":{"url":"1-1.html","title":"1.1 二进制和十六进制数","keywords":"","body":"1.1 二进制和十六进制数 本节给出了计算机存储中二进制数和十六进制数之间的关系。 日常生活中我们用十进制来表示数，逢十进一。 计算机由于其典型的开关式设计，无法直接采用十进制存储，用的是二进制01式的存储（0关1开）。 二进制权值与十进制不同： 11010=1∗104+1∗103+0∗102+1∗101+0∗10011010=1*10^4+1*10^3+0*10^2+1*10^1+0*10^011010=1∗10​4​​+1∗10​3​​+0∗10​2​​+1∗10​1​​+0∗10​0​​ 110102=1∗24+1∗23+0∗22+1∗21+0∗20=2611010_2=1*2^4+1*2^3+0*2^2+1*2^1+0*2^0=2611010​2​​=1∗2​4​​+1∗2​3​​+0∗2​2​​+1∗2​1​​+0∗2​0​​=26 究其根本原因是系数相同而权值不同。 同理十六进制即权值为16. 十进制 十六进制 二进制 0 0 0 1 1 1 2 2 10 3 3 11 4 4 100 5 5 101 6 6 110 7 7 111 8 8 1000 9 9 1001 10 A 1010 11 B 1010 12 C 1100 13 D 1101 14 E 1110 15 F 1111 可以发现，如果将不足4位的二进制数的前置空位补上0，那么可以认为每四位二进制数对应一个十六进制数。 同理八进制数可用三位二进制数表示，三位十六进制数可用四位八进制数表示。 进制转换高中数学讲过。 十进制转N进制——除N取余法 N进制转十进制——按位展开法 Written by Visors all right reserved，powered by Gitbook本文档更新于： 2019-09-02 14:23 "},"1-2.html":{"url":"1-2.html","title":"1.2 字符编码","keywords":"","body":"1.2 字符编码 计算机无法直接存储字符，故而用特定数值来表示各种字符，最常见的表示规则是美国信息交换标准代码ASCII，它建立了字符与数值间的映射关系。 ASCII码表 表中0016∼1F1600_{16}\\sim1F_{16}00​16​​∼1F​16​​比较特殊，他们不是常规意义上的字符（打印输出字符），他们是控制字符。例如特殊服务控制ESC、回车CR、换行LF等。 Written by Visors all right reserved，powered by Gitbook本文档更新于： 2019-09-02 16:57 "},"1-3.html":{"url":"1-3.html","title":"1.3 有符号整数的二进制补码表示","keywords":"","body":"1.3 有符号整数的二进制补码表示 前面小节已介绍过二进制和ASCII，如果要在计算机中表示数，可以对应的用到这两种表示方法： ASCII表示 把数字看成字符，拆成一个个字符存在一起 二进制表示 进制转换 这两种表示方法在表示时有两点问题值得注意： 表示数的有效位是有限的 如何表示负数并不明确 ASCII表示 常见ASCII码为0~127，正好可以用7位表示。8位1字节，附加位（左侧或最高位）设为0即可。 如果要表示负数，负号（减号）的ASCII为2D，用一位记下即可。 −817=2D 38 31 37-817=2D~38~31~37−817=2D 38 31 37 解决第一个问题的方法是固定字节长度，位数不足时补前导0. 也可以用长度可变的字节数，但须规定以非数字字符结尾（用以分割）。 二进制表示 将十进制转化为二进制存储。 解决第一个问题同样是定长补前导0，下面这个例子是2字节（16位）定长表示（1字节=8位 1字=16位）。 69710=10101110012=00000010101110012=02B916697_{10}=1010111001_2=0000001010111001_2=02B9_{16}697​10​​=1010111001​2​​=0000001010111001​2​​=02B9​16​​ 这样便可以很好的表示非负数和无符号数，但负号是符号不是数值，不能拆解在二进制表示中。 当然你也可以说负号ASCII码2D162D_{16}2D​16​​可以拆成1011012101101_2101101​2​​，但若真这样做，负号将会占用6位，考虑到整数的普遍性，我们在对每一个数存储时都要考虑其成为负数的可能性，那么每个数都要预留一个“负数位”，这样会造成巨大的空间浪费，是极其不成熟的。我们采用“二进制补码表示法”解决这个问题。 二进制补码表示 规定二进制数最左边一位为符号位。 01111111111111112=7FFF16=32767100111111111111111_2=7FFF_{16}=32767_{10}0111111111111111​2​​=7FFF​16​​=32767​10​​ 最左边的符号位被置为0，表示这个数是正数。 但这并不意味着负数的符号位为1，然后其他部分与之完全相同（这种表示方法叫做原码）。 表示负数惯用的做法是对其取补： 对于定长二进制数，用1后跟二进制位数个0表示的二进制数减去无符号部分。 下面这个例子展示了十进制负数取补的过程。 −7610=1000016−7610=1000016−004C16=FFB416-76_{10}=10000_{16}-76_{10}=10000_{16}-004C_{16}=FFB4_{16}−76​10​​=10000​16​​−76​10​​=10000​16​​−004C​16​​=FFB4​16​​ 减法部分参照竖式运算 减去无符号部分可以视为减绝对值 单字长为16位，所以用17位100000000000000002=1000016=21610000000000000000_2=10000_{16}=2^{16}10000000000000000​2​​=10000​16​​=2​16​​减无符号部分取补。我们称FFB4FFB4FFB4为−76-76−76的补码。非负数的补码只需在前面加前导0占位。 补码的基本性质 补码表示数的范围 由于我们规定了符号位，所以以单字长二进制数为例，最大正整数为0111111111111111=1000000000000000−1=215−10111111111111111=1000000000000000-1=2^{15}-10111111111111111=1000000000000000−1=2​15​​−1 可以推广一下，即对于NNN位二进制数，最大正整数为2N−1−12^{N-1}-12​N−1​​−1. 自然，我们也想知道最小负整数，我们可以从将二进制补码还原为负数这一角度入手。 根据符号位的定义，第一位为1时为负数，换言之，负数的补码范围为1000000000000000∼11111111111111111000000000000000\\sim11111111111111111000000000000000∼1111111111111111 分析原操作，设该负数为−x-x−x，长度为NNN位（其中有一个符号位，故有效位数实际上是N−1N-1N−1），补码为yyy，那么有2N−x=y2^N-x=y2​N​​−x=y，在yyy已知的情况下： 2N−x=y2^N-x=y2​N​​−x=y y−2N=−xy-2^N=-xy−2​N​​=−x x=2N−yx=2^N-yx=2​N​​−y 由负数补码范围知2N−1≤y2N2^{N-1}\\leq y2​N−1​​≤y2​N​​，那么yyy越小，2N−y2^N-y2​N​​−y就越大，xxx就越大，−x-x−x就越小 即−x-x−x在y=2N−1y=2^{N-1}y=2​N−1​​时取得最小值，最小为−2N−1-2^{N-1}−2​N−1​​ 也就是说 NNN位表示的有符号数的范围为−2N−1∼2N−1−1-2^{N-1}\\sim2^{N-1}-1−2​N−1​​∼2​N−1​​−1 补码的还原 2N−1−x=y2^{N-1}-x=y2​N−1​​−x=y 2N−1−y=2N−1−(2N−1−x)=x2^{N-1}-y=2^{N-1}-(2^{N-1}-x)=x2​N−1​​−y=2​N−1​​−(2​N−1​​−x)=x 也就是说，对一个数二次取补会得到它的本身。 但需要注意，取补与表示为补码为不同的操作，事实上： 如果原数是一个非负数，当我们知道它的补码表示（等于原数）时，再表示出这个补码的补码，仍然是原数，因为这个过程中数都为非负数，非负数的补码操作只是补足前导0. 如果原数是一个负数，当我们知道它的补码表示（对无符号部分求补）时，再表示出这个补码的补码，会得到原数的无符号部分。 所以还原补码的正确操作应该是先判断补码的符号，确定原数是不是负数后，再对照上面的规则求出。 一个简单的判断符号的方法是，如果这个补码大于该长度二进制数表示的一半，那么原数是负数；反之为非负数。对于字长的二进制补码，”一半“指的是8000；对于字节的二进制补码，”一半“指的是80. 由此结论，我们还可以简化前面补码表示数的范围的推理过程。 取补的另一种方法 由于二进制太长书写不变，此前我们都是用十六进制缩写二进制，这种表示下，做十六进制减法效率上很高。实际上，我们还有另一种取补方法： 原码非符号位按位取反+1 前面的例子我们已经知道−76-76−76表示成字节的二进制补码是B416B4_{16}B4​16​​ 我们尝试一下按位取反 按位取反既是对每位取反，1成0，0成1.这里接用很多高级语言按位取反运算符~表示 −76=110011002-76=11001100_2−76=11001100​2​​ ∼76=101100112\\sim76=10110011_2∼76=10110011​2​​ 再加上1，得到的结果便是 101101002=B41610110100_2=B4_{16}10110100​2​​=B4​16​​ 与前面的结果一致。 Written by Visors all right reserved，powered by Gitbook本文档更新于： 2019-10-03 18:42 "},"1-4.html":{"url":"1-4.html","title":"1.4 二进制补码数的加减法","keywords":"","body":"1.4 二进制补码数的加减法 从本节开始，我将摒弃之前过细描述的臃肿感，略过人人皆知的定义，采用更加精炼的语言，减少在书本重现上浪费的时间，转而让我从每日的忙碌中解放出来，可以更细心的阅读中英教材，专注书本知识的注意点，以及我个人学习经验对之的拓展，真正使复杂的问题简单化，使抽象的东西形象化。 两种重要情况 有符号数用二进制补码形式表示，但二进制补码数也可看作无符号数，所以有符号数相加并不完全等于补码数相加。 在二进制补码数的加减法中，我们关注计算中的两种情况： 向符号位的进位 符号位进位输出 向符号位的进位 举一例说明： 0100 1000 0011 1111 +0110 0100 0101 1010 =1010 1100 1001 1001 可以看到，当483F483F483F与645A645A645A相加后，得到的结果AC99AC99AC99超过了我们说的字长的二进制补码的分界线800080008000，抑或是说符号位由000变为111。我们称这种情况为向符号位的进位。 符号位进位输出 再举一例： ​ 1110 1001 1111 1111 +1000 1100 1111 0000 =10111 0110 1110 1111 可以看到E9FFE9FFE9FF和8CF08CF08CF0相加后，得到的结果176EF176EF176EF超过了字长的存储位数限制。实际计算机存储中，该结果会被强行截断成字长（截去超出范围）。在这个例子中，实际结果为76EF76EF76EF。 溢出 当加法运算中发生溢出overflow时，得到的结果存在错误。我们可以人为判断溢出是否发生，计算机硬件也可以判断。判断溢出与否的方法就跟上述两种情况有关。事实上，溢出并不如其字面上那样，“是单纯的超过数据范围”，而应该是如下情况： 向符号位的进位 符号位进位输出 溢出 0 0 0 0 1 1 1 0 1 1 1 0 这张类似真值表的情况表给出了判断溢出是否发生的简单方法。 二进制减法 将减法看作加上对应数的负数，即加负数的补码即可。 Written by Visors all right reserved，powered by Gitbook本文档更新于： 2019-09-16 21:12 "},"2.html":{"url":"2.html","title":"2 计算机系统的组成","keywords":"","body":"2 计算机系统的组成 本章更进一步地介绍了一些计算机导论中介绍过的硬件知识，但存在不少未提到的重点内容。汇编以硬件层面为重，我们有必要深入理解这一部分内容。这些内容将以杂谈的形式呈现在文末。 教材以80386或更高的处理器以及32位操作系统为基准。 Written by Visors all right reserved，powered by Gitbook本文档更新于： 2019-09-16 23:55 "},"2-1.html":{"url":"2-1.html","title":"2.1 微机硬件：存储器","keywords":"","body":"2.1 微机硬件：存储器 两种存储模式 平面存储模式 又称线性内存模型，在这种模式下，应用程序看到的内存是一个单独的连续地址（本书为32位地址）空间。CPU可以直接（且线性）寻址所有可利用的内存位置，无需诉诸任何内存分段或分页机制，平面存储器模式利用到了虚拟内存技术。 分段存储模式 在该模式中，PC存储器被看做是段的集合，每个段64KB。其中： 64KB=64×1024Byte=216Byte64KB=64\\times 1024Byte=2^{16}Byte64KB=64×1024Byte=2​16​​Byte 即每个段有可用2162^{16}2​16​​个可用空间，我们可以用4位十六进制数为之编号，称为偏移量。 那么32位空间可被分成的段数即为 232÷216=2162^{32}\\div 2^{16}=2^{16}2​32​​÷2​16​​=2​16​​ 同理我们也可以对段编号，对应4位十六进制编号，称为段号。 由此任意存储单元地址可被表示为 段号:偏移量 喜闻乐见吐槽环节 平面存储模式的英文应为flat memory model，书中漏了model，分段存储模式也是。 168Byte=232Byte=4GB16^8Byte=2^{32}Byte=4GB16​8​​Byte=2​32​​Byte=4GB，这也是为什么32位系统最多只能装4G内存的原因。现实生活中随着各种应用、游戏占用内存提升，4G内存完全不能满足需求，所以它们逐渐抛弃32位软件的开发，只支持64位。前几年很多3A大作出来的时候，身边很多人都说自己电脑32位玩不了。快看看你Steam库存的游戏配置需求。不过现在64位电脑在新用户中基本上普及了。 Written by Visors all right reserved，powered by Gitbook本文档更新于： 2019-09-17 00:34 "},"2-2.html":{"url":"2-2.html","title":"2.2 微机的硬件：CPU","keywords":"","body":"2.2 微机的硬件：CPU 这节第一次出现了汇编指令。 寄存器 寄存器名前加E是32位寄存器 数据寄存器 数据寄存器 低位字0~15 低位字节0~7 高位字节8~15 EAX AX AL AH EBX BX BL BH ECX CX CL CH EDX DX DL DH 通用寄存器 索引寄存器ESI、EDI，SI代表索引源，DI代表目的索引 栈指针ESP 基址指针寄存器EBP 段寄存器 CS、DS、ES、FS、GS、SS 指令寄存器EIP 指令指针，编程人员不能直接访问。用来存放当前指令的下一条指令的地址。CPU该执行哪条指令就是通过IP来指示的。 标志寄存器EFLAGS 好好看书🙃 Written by Visors all right reserved，powered by Gitbook本文档更新于： 2019-09-17 01:10 "},"2-3.html":{"url":"2-3.html","title":"2.3 微机硬件：输入/输出设备","keywords":"","body":"2.3 微机硬件：输入/输出设备 水过😏 Written by Visors all right reserved，powered by Gitbook本文档更新于： 2019-09-26 01:11 "},"2-4.html":{"url":"2-4.html","title":"2.4 PC软件","keywords":"","body":"2.4 PC软件 操作系统 程序运行在对应的操作系统上。操作系统界面有命令行界面（尝试Win+R运行“cmd”），也有图形用户界面（你现在看到的）。 文本编辑器 VimVimVim d=\\====(￣▽￣*)b 语言翻译器和链接器 千万不要IDE、编译器、文本编辑器傻傻分不清啊 解释器：执行程序的程序 编译器：把特定语言源代码翻译成CPU可执行指令 链接器：链接不同代码，包含在编译器中 调试器：你的写bugDebug利器 汇编器：类似编译器，只不过翻译的是汇编语言 翻译器：解释器、编译器、汇编器的统称 集成开发环境：IDE，包含上述若干工具的程序，比如Visual Studio。 Visual Studio Code是文本编辑器 （严肃脸）（认真脸） Written by Visors all right reserved，powered by Gitbook本文档更新于： 2019-09-17 01:25 "},"3.html":{"url":"3.html","title":"3 汇编语言的要素","keywords":"","body":"3 汇编语言的要素 Written by Visors all right reserved，powered by Gitbook本文档更新于： 2019-09-24 10:59 "},"3-1.html":{"url":"3-1.html","title":"3.1 汇编语句","keywords":"","body":"3.1 汇编语句 分行 当单行代码过长时，会严重影响程序的可阅读性。拿python举个例子： print(3) print(“Ceeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeb!”) print(6) MASM允许在每行末尾使用backslash()将不长于512个字符的单句拆成多行。 注释 使用semicolon(;)将其至行末的代码设为注释。 可用backslash将注释分行。 三种语句 汇编语言语句主要分为三种： 指令性语句instruction：通过汇编器翻译成目标代码 指示性语句directive：告诉汇编器做某种操作 宏语句marco：一系列语句的缩写 一条语句通常可以表示为下面的形式： (名字:) 助记符 操作数 ;注释 WaitWaitWait，我怎么又开始废话多了 总之，这章有点蠢，提了很多东西又没讲明白，看了上面直接看下章吧。 Written by Visors all right reserved，powered by Gitbook本文档更新于： 2019-09-26 00:38 "},"3-2.html":{"url":"3-2.html","title":"3.2 一个完整的实例","keywords":"","body":"3.2 一个完整的实例 代码一下丢出一堆莫名其妙的东西，虽说跟我们初学Hello World一样，但有些内容甚至整本书直接不解释。话不多说直接开吐槽。 NEAR32是距离的一种，类似的还有near,far,near16,far16,far32，在win32中只有平坦的段flat无所谓距离，所以这个参数通常忽略。 stdcall是语言类型，类似的还有c,syscall,basic,fortran,pascal，如果忽略，则使用程序头部.model定义的值。 注意区分EQU与MOV，前者类似定义符号常量，后者类似赋值。 .DATA段像极了Pascal等语言，变量要统一声明在特定部分。 prompt1 BYTE \"Enter first number: \",0这句话，书中说是为数字0保留了一个字节长度。请这样想： 多个操作数中间以逗号分隔 字符串是多个字符操作数的集中表示 数字0准确的说表示的是空字符00 空字符作用类似C字符串结尾的隐式'\\0' 之所以output label1能输出label1本身的内容还有sum的内容，是因为字符串以空字符结尾，在.DATA声明中： label1 BYTE cr, Lf, \"The sum is \" sum BYTE 11, DUP (?) BYTE cr, Lf, 0 是连续内存，output一直会输出到空字符0为止 Written by Visors all right reserved，powered by Gitbook本文档更新于： 2019-12-22 14:33 "},"3-3.html":{"url":"3-3.html","title":"3.3 程序的汇编、链接和运行","keywords":"","body":"3.3 程序的汇编、链接和运行 了解下windbg使用过程 Written by Visors all right reserved，powered by Gitbook本文档更新于： 2019-09-26 01:11 "},"3-4.html":{"url":"3-4.html","title":"3.4 汇编器清单文件","keywords":"","body":"3.4 汇编器清单文件 建议自行运行，得到.LST文件，打开对照.asm看一看。之前说过的3.2说过的output模式在这里能看的很清楚。 .DATA 形式 偏移量 内存内容 名称 类型 语法内容 偏移量 偏移量从00000000开始，根据DATA声明，各语句有对应的偏移量： 单位 产生偏移量/数据 BYTE 1 WORD 2 DWORD 4 内存内容 特别注意的是用DUP开出来的空间的内容，显示上是[00]，但并不是指空字符。 Written by Visors all right reserved，powered by Gitbook本文档更新于： 2019-10-03 18:14 "},"3-5.html":{"url":"3-5.html","title":"3.5 常数操作数","keywords":"","body":"3.5 常数操作数 整数的表示法 下标 基数 进制 H 16 十六进制 B 2 二进制 O/Q 8 八进制 无 10 十进制 不区分大小写。 整数表示范围 类型 位数 有符号数 无符号数 BYTE 8 −128∼127-128\\sim 127−128∼127 0∼2550\\sim 2550∼255 WORD 16 −32768∼32767-32768\\sim 32767−32768∼32767 0∼655350\\sim 655350∼65535 DWORD 32 −2147483648∼2147483647-2147483648\\sim 2147483647−2147483648∼2147483647 0∼42949672950\\sim 42949672950∼4294967295 无须死记，回忆一下前面推导的公式： NNN位表示的有符号数的范围为−2N−1∼2N−1−1-2^{N-1}\\sim2^{N-1}-1−2​N−1​​∼2​N−1​​−1 字符表示法 单字符的单引号表示法，如'm' ;数值为6D 单字符的ASCII码表示法，如6dh ;数值为6D 多字符的双引号字符串表示法，如\"Joe\" 表达式 操作数可以是一个包含算数运算符或者其它运算符的表达式，如 gross WORD 10*15-7+1 汇编器会对表达式求值，然后将结果用于汇编。 若想详细了解汇编语言运算符，可移步3.8 常见运算符 数组 细心的你应该发现了单名字多操作数的声明方法，没错这就是数组，例如 words WORD 10, 20, 30, 40 DblArray DWORD 100 DUP (999) String BYTE \"13481321\", 0 words开辟了4个字空间，DblArray开辟了1000个双字空间。 访问内部元素的方法与C/C++类似： [数组名+下标] 如[String+1]就是'3' 并且这个下标可以超过数组长度，直接访问到后面的内存。 在书上代码中，我们可以通过output [prompt1+22]输出prompt2 此外 P45书上有行代码 starsAndSpaces BYTE 24 DUP (\"*\"), '*' 有印刷错误，应为 starsAndSpaces BYTE 24 DUP (\"* \"), '*' 漏了一个空格 Written by Visors all right reserved，powered by Gitbook本文档更新于： 2019-10-03 23:53 "},"3-6.html":{"url":"3-6.html","title":"3.6 指令中的操作数","keywords":"","body":"3.6 指令中的操作数 操作数寻址方式 如何判断操作数的寻址方式？ 形式 寻址方式 常数 立即数寻址 寄存器名 寄存器寻址 [寄存器名] 寄存器间接寻址 变量名 直接寻址 上表用来答题即可，想进一步了解，需要仔细读一下课本。 PTR标识符 寄存器中其实存的不是数据本身，而是数据存放位置的地址，所以有时我们无法判断这个内存地址的长度。PTR标识符用来告诉汇编器这个内存地址的长度，格式如下： 类型 PTR 比如BYTE PTR 隐含操作数 有时候，一些操作数不用显式地表示出来。比如乘法指令mul： mul bh 看上去只有一个操作数，其实隐含了另一个（通常是）存在AL寄存器中地操作数。 Written by Visors all right reserved，powered by Gitbook本文档更新于： 2019-10-03 23:41 "},"3-7.html":{"url":"3-7.html","title":"3.7 使用IO.H中宏的输入/输出","keywords":"","body":"3.7 使用IO.H中宏的输入/输出 这是作者写的一个头文件，里面包含里一些输入输出的宏指令，应仔细阅读书中这节的内容。 Written by Visors all right reserved，powered by Gitbook本文档更新于： 2019-10-03 23:43 "},"3-8.html":{"url":"3-8.html","title":"3.8 常见运算符","keywords":"","body":"3.8 常见运算符 Written by Visors all right reserved，powered by Gitbook本文档更新于： 2019-10-03 23:48 "},"4.html":{"url":"4.html","title":"4 基本指令","keywords":"","body":"4 基本指令 一些基本指令，很重要。 Written by Visors all right reserved，powered by Gitbook本文档更新于： 2019-12-24 13:08 "},"4-1.html":{"url":"4-1.html","title":"4.1 复制数据指令","keywords":"","body":"4.1 复制数据指令 时钟周期 时钟周期也称为振荡周期，定义为时钟频率的倒数。时钟周期是计算机中最基本的、最小的时间单位。在一个时钟周期内，CPU仅完成一个最基本的动作。时钟周期是一个时间的量。时钟周期表示了SDRAM所能运行的最高频率。更小的时钟周期就意味着更高的工作频率。 简单来说，一条指令的时钟周期数越小，意味着运行越快 MOV指令 MOV 指令将源操作数复制到目的操作数。作为数据传送（data transfer）指令，它几乎用在所有程序中。在它的基本格式中，第一个操作数是目的操作数，第二个操作数是源操作数： MOV destination, source 其中，目的操作数的内容会发生改变，而源操作数不会改变。这种数据从右到左的移动与 C++ 或 Java中的赋值语句相似： destination = source; 在几乎所有的汇编语言指令中，左边的操作数是目的操作数，而右边的操作数是源操作数。只要按照如下原则，MOV 指令使用操作数是非常灵活的。 两个操作数必须是同样的大小。 两个操作数不能同时为内存操作数。 指令指针寄存器（IP、EIP 或 RIP）不能作为目的操作数。 下面是 MOV 指令的标准格式： MOV reg, reg MOV mem, reg MOV reg, mem MOV mem, imm MOV reg, imm ;reg:寄存器操作数 ;mem:内存操作数 ;imm:立即数 XCHG指令 XCHG（交换数据）指令交换两个操作数内容。该指令有三种形式： XCHG reg, reg XCHG reg, mem XCHG mem, reg 除了 XCHG 指令不使用立即数作操作数之外，XCHG 指令操作数的要求与 MOV 指令操作数要求是一样的。 在数组排序应用中，XCHG 指令提供了一种简单的方法来交换两个数组元素。下面是几个使用 XCHG 指令的例子。 xchg ax, bx ;交换 16 位寄存器内容 xchg ah, al ;交换 8 位寄存器内容 xchg var1, bx ;交换 16 位内存操作数与 BX 寄存器内容 xchg eax, ebx ;交换 32 位寄存器内容 如果要交换两个内存操作数，则用寄存器作为临时容器，把 MOV 指令与 XCHG 指令一起使用： mov ax,val1 xchg ax,val2 mov val1,ax Written by Visors all right reserved，powered by Gitbook本文档更新于： 2019-12-22 15:16 "},"4-2.html":{"url":"4-2.html","title":"4.2 整数的加法和减法指令","keywords":"","body":"4.2 整数的加法和减法指令 运算结果标志位 进位标志CF(Carry Flag) 进位标志CF主要用来反映运算是否产生进位或借位。如果运算结果的最高位产生了一个进位或借位，那么，其值为1，否则其值为0。 使用该标志位的情况有：多字(字节)数的加减运算，无符号数的大小比较运算，移位操作，字(字节)之间移位，专门改变CF值的指令等。 奇偶标志PF(Parity Flag) 奇偶标志PF用于反映运算结果中“1”的个数的奇偶性。如果“1”的个数为偶数，则PF的值为1，否则其值为0。 利用PF可进行奇偶校验检查，或产生奇偶校验位。在数据传送过程中，为了提供传送的可靠性，如果采用奇偶校验的方法，就可使用该标志位。 辅助进位标志AF(Auxiliary Carry Flag) 在发生下列情况时，辅助进位标志AF的值被置为1，否则其值为0： 在字操作时，发生低字节向高字节进位或借位时； 在字节操作时，发生低4位向高4位进位或借位时。 对以上6个运算结果标志位，在一般编程情况下，标志位CF、ZF、SF和OF的使用频率较高，而标志位PF和AF的使用频率较低。 零标志ZF(Zero Flag) 零标志ZF用来反映运算结果是否为0。如果运算结果为0，则其值为1，否则其值为0。在判断运算结果是否为0时，可使用此标志位。 符号标志SF(Sign Flag) 符号标志SF用来反映运算结果的符号位，它与运算结果的最高位相同。在微机系统中，有符号数采用补码表示法，所以，SF也就反映运算结果的正负号。运算结果为正数时，SF的值为0，否则其值为1。 溢出标志OF(Overflow Flag) 溢出标志OF用于反映有符号数加减运算所得结果是否溢出。如果运算结果超过当前运算位数所能表示的范围，则称为溢出，OF的值被置为1，否则，OF的值被清为0。 “溢出”和“进位”是两个不同含义的概念，不要混淆。 整数加减指令 INC 和 DEC 指令 INC（增加）和DEC（减少）指令分别表示寄存器或内存操作数加 1 和减 1。语法如下所示： INC reg/mem DEC reg/mem 下面是一些例子： .data myWord WORD 1000h .code inc myWord ; myWord = 1001h mov bx, myWord dec bx ; BX = 1000h 根据目标操作数的值，溢岀标志位、符号标志位、零标志位、辅助进位标志位、进位标志位和奇偶标志位会发生变化。INC 和 DEC 指令不会影响进位标志位。 ADD 指令 ADD 指令将长度相同的源操作数和目的操作数进行相加操作。语法如下： ADD destination, source 在操作中，源操作数不能改变，相加之和存放在目的操作数中。该指令可以使用的操作数与 MOV 指令相同。下面是两个 32 位整数相加的短代码示例： .data var1 DWORD 10000h var2 DWORD 20000h .code mov eax,var1 ; EAX = 10000h add eax,var2 ; EAX = 30000h 标志位：进位标志位、零标志位、符号标志位、溢出标志位、辅助进位标志位和奇偶标 志位根据存入目标操作数的数值进行变化。 SUB 指令 SUB 指令从目的操作数中减去源操作数。该指令对操作数的要求与 ADD 和 MOV 指令相同。指令语法如下： SUB destination, source 下面是两个 32 位整数相减的短代码示例： .data var1 DWORD 30000h var2 DWORD 10000h .code mov eax,var1 ; EAX = 30000h sub eax,var2 ; EAX = 20000h 标志位：进位标志位、零标志位、符号标志位、溢出标志位、辅助进位标志位和奇偶标 志位根据存入目标操作数的数值进行变化。 NEG 指令 NEG（非）指令通过把操作数转换为其二进制补码，将操作数的符号取反。下述操作数可以用于该指令： NEG reg NEG mem 提示：将目标操作数按位取反再加 1，就可以得到这个数的二进制补码。 标志位：进位标志位CF、零标志位ZF、符号标志位SF、溢出标志位、辅助进位标志位和奇偶标志位根据存入目标操作数的数值进行变化。 Written by Visors all right reserved，powered by Gitbook本文档更新于： 2019-12-22 15:28 "},"4-3.html":{"url":"4-3.html","title":"4.3 乘法指令","keywords":"","body":"4.3 乘法指令 MUL 指令 乘数和被乘数的大小必须保持一致，乘积的大小则是它们的一倍。这三种类型都可以使用寄存器和内存操作数，但不能使用立即数： MUL reg/mem8 MUL reg/meml6 MUL reg/mem32 MUL 指令中的单操作数是乘数。下表按照乘数的大小，列出了默认的被乘数和乘积。由于目的操作数是被乘数和乘数大小的两倍，因此不会发生溢岀。 被乘数 乘数 乘积 AL reg/mem8 AX AX reg/mem16 DX:AX EAX reg/mem32 EDX:EAX 如果乘积的高半部分不为零，则 MUL 会把进位标志位和溢出标志位置 1。因为进位标志位常常用于无符号数的算术运算，在此我们也主要说明这种情况。例如，当 AX 乘以一个 16 位操作数时，乘积存放在 DX 和 AX 寄存器对中。其中，乘积的高 16 位存放在 DX，低 16 位存放在 AX。如果 DX 不等于零，则进位标志位置 1，这就意味着隐含的目的操作数的低半部分容纳不了整个乘积。 有个很好的理由要求在执行 MUL 后检查进位标志位，即，确认忽略乘积的高半部分是否安全。 .data val1 WORD 2000h val2 WORD 0l00h .code mov ax, val1 ; AX = 2000h mul val2 ; DX:AX = 00200000h, CF = 1 IMUL 指令 IMUL（有符号数乘法）指令执行有符号整数乘法。与 MUL 指令不同，IMUL 会保留乘 积的符号，实现的方法是，将乘积低半部分的最高位符号扩展到高半部分。 单操作数格式 单操作数格式将乘积存放在 AX、DX:AX 或 EDX:EAX 中： IMUL reg/mem8 ; AX = AL * reg/mem8 IMUL reg/meml6 ; DX:AX = AX * reg/meml6 IMUL reg/mem32 ; EDX:EAX = EAX * reg/mem32 和 MUL 指令一样，其乘积的存储大小使得溢出不会发生。同时，如果乘积的高半部分不是其低半部分的符号扩展，则进位标志位和溢出标志位置 1。利用这个特点可以决定是否忽略乘积的高半部分。 双操作数格式（32位模式） 32 位模式中的双操作数 IMUL 指令把乘积存放在第一个操作数中，这个操作数必须是寄存器。第二个操作数（乘数）可以是寄存器、内存操作数和立 即数。16位格式如下所示： IMUL regl6, reg/meml6 IMUL regl6, imm8 IMUL regl6, imml6 32 位操作数类型如下所示，乘数可以是 32 位寄存器、32 位内存操作数或立即数（8 位 或 32 位）： IMUL reg32, reg/mem32 IMUL reg32, inun8 IMUL reg32, imm32 双操作数格式会按照目的操作数的大小来截取乘积。如果被丢弃的是有效位，则溢出标志位和进位标志位置 1。因此，在执行了有两个操作数的 IMUL 操作后，必须检查这些标志位中的一个。 三操作数格式 32 位模式下的三操作数格式将乘积保存在第一个操作数中。第二个操作数可以是 16 位寄存器或内存操作数，它与第三个操作数相乘，该操作数是一个8位或16 位立即数： IMUL regl6, reg/meml6,imm8 IMUL regl6, reg/meml6, iirrnl6 而 32 位寄存器或内存操作数可以与 8 位或 32 位立即数相乘： IMUL reg32, reg/mem32, imm8 IMUL reg32, reg/mem32, imm32 IMUL 执行时，若乘积有效位被丢弃，则溢出标志位和进位标志位置 1。因此，在执行了有三个操作数的 IMUL 操作后，必须检查这些标志位中的一个。 Written by Visors all right reserved，powered by Gitbook本文档更新于： 2019-12-22 15:37 "},"4-4.html":{"url":"4-4.html","title":"4.4 除法指令","keywords":"","body":"4.4 除法指令 DIV 指令 32 位模式下，DIV（无符号除法）指令执行 8 位、16 位和 32 位无符号数除法。其中，单寄存器或内存操作数是除数。格式如下： DIV reg/mem8 DIV reg/meml6 DIV reg/mem32 下表给出了被除数、除数、商和余数之间的关系： 被除数 除数 商 余数 AX reg/mem8 AL AH DX:AX reg/mem16 AX DX EDX:EAX reg/mem32 EAX EDX 64 位模式下，DIV 指令用 RDX:RAX 作被除数，用 64 位寄存器和内存操作数作除数, 商存放到 RAX，余数存放在 RDX 中。 有符号除法 有符号除法几乎与无符号除法相同，只有一个重要的区别：在执行除法之前，必须对被除数进行符号扩展。 符号扩展是指将一个数的最高位复制到包含该数的变量或寄存器的所有高位中。为了说明为何有此必要，让我们先不这么做。下面的代码使用 MOV 把 -101 赋给 AX，即 DX:AX 的低半部分： .data wordVal SWORD -101 ; 009Bh .code mov dx, 0 mov ax, wordVal ; DX:AX = 0000009Bh (+155 mov bx, 2 ; BX 是除数 idiv bx ; DX:AX除以BX (有符号操作) 可惜的是，DX:AX 中的 009Bh 并不等于 -101，它等于 +155。因此，除法产生的商为 +77，这不是所期望的结果。而解决该问题的正确方法是使用 CWD( 字转双字 ) 指令，在进行除法之前在 DX:AX 中对 AX 进行符号扩展： .data wordVal SWORD -101 ; 009Bh .code mov dx, 0 mov ax, wordVal ; DX:AX = 0000009Bh (+155) cwd ; DX:AX = FFFFFF9Bh (-101 ) mov bx, 2 idiv bx x86 指令集有几种符号扩展指令。首先了解这些指令，然后再将其应用到有符号除法指令 IDIV 中。 符号扩展指令（CBW、CWD、CDQ） Intel 提供了三种符号扩展指令：CBW、CWD 和 CDQ。 CBW（字节转字）指令将 AL 的符号位扩展到 AH，保留了数据的符号。如下例所示，9Bh（AL 中）和 FF9Bh （AX 中）都等于十进制的 -101： .data byteVal SBYTE -101 ; 9Bh .code mov al, byteVal ; AL = 9Bh cbw ; AX = FF9Bh CWD（字转双字）指令将 AX 的符号位扩展到 DX： .data wordVal SWORD -101 ; FF9Bh .code mov ax, wordVal ; AX = FF9Bh cwd ; DX:AX = FFFFFF9Bh CDQ（双字转四字）指令将 EAX 的符号位扩展到 EDX： .data dwordVal SDWORD -101 ; FFFFFF9Bh .code mov eax, dwordVal cdq ; EDX:EAX = FFFFFFFFFFFFFF9Bh IDIV 指令 IDIV（有符号除法）指令执行有符号整数除法，其操作数与 DIV 指令相同。执行 8 位除法之前，被除数（AX）必须完成符号扩展。余数的符号总是与被除数相同。 【示例 1】下述指令实现 -48 除以 5。IDIV 执行后，AL 中的商为 -9，AH 中的余数为 -3： .data byteVal SBYTE -48 ;D0 十六进制 .code mov al, byteVal ;被除数的低字节 cbw ;AL扩展到AH mov bl,+5 ;除数 idiv bl ;AL = -9, AH = -3 下图展示了 AL 是如何通过 CBW 指令符号扩展为 AX 的： 为了理解被除数的符号扩展为什么这么重要，现在在不进行符号扩展的前提下重复之前的例子。下面的代码将 AH 初始化为 0，这样它就有了确定值，然后没有用 CBW 指令转换被除数就直接进行了除法： .data byteVal SBYTE -48 ;D0 十六进制 .code mov ah, 0 ;被除数高字节 mov al, byteVal ;被除数低字节 mov bl, +5 ;除数 idiv bl ;AL = 41z AH = 3 执行除法之前，AX=00D0h ( 十进制数 208)。 IDIV 把这个数除以 5，生成的商为十进制数 41，余数为3。这显然不是正确答案。 【示例 2】16 位除法要求 AX 符号扩展到 DX。下例执行 -5000 除以 256： .data wordVal SWORD -5000 .code mov ax, wordVal ;被除数的低字 cwd ;AX扩展到DX mov bx, +256 ;除数 idiv bx ;商 AX=-19,余数 DX=-136 【示例 3】32 位除法要求 EAX 符号扩展到 EDX。下例执行 50 000 除以 -256： .data dwordVal SDWORD +50000 .code mov eax, dwordVal ;被除数的低双字 cdq ;EAX 扩展至q EDX mov ebx, -256 ;除数 idiv ebx ;商 EAX=-195,余数 EDX=+80 执行 DIV 和 IDIV 后，所有算术运算状态标志位的值都不确定。 Written by Visors all right reserved，powered by Gitbook本文档更新于： 2019-12-24 13:40 "},"4-5.html":{"url":"4-5.html","title":"4.5 大数的加减","keywords":"","body":"4.5 大数的加减 Written by Visors all right reserved，powered by Gitbook本文档更新于： 2019-12-22 14:54 "},"4-6.html":{"url":"4-6.html","title":"4.6 微代码抽象级","keywords":"","body":"4.6 微代码抽象级 简言之就是汇编语言还不算底层。 介于数字电路级和机器语言级之间还有个微代码集，一般集成在CPU的永久存储器里。 Written by Visors all right reserved，powered by Gitbook本文档更新于： 2019-12-22 20:14 "},"5.html":{"url":"5.html","title":"5 分支和循环","keywords":"","body":"5 分支和循环 说白了就是用cmp和jmp组合实现分支和循环的方法。 Written by Visors all right reserved，powered by Gitbook本文档更新于： 2019-12-24 13:08 "},"5-1.html":{"url":"5-1.html","title":"5.1 无条件转移","keywords":"","body":"5.1 无条件转移 JMP 指令 JMP 指令无条件跳转到目标地址，该地址用代码标号来标识，并被汇编器转换为偏移 量。语法如下所示： JMP destination 当 CPU 执行一个无条件转移时，目标地址的偏移量被送入指令指针寄存器，从而导致迈从新地址开始继续执行。 JMP 指令提供了一种简单的方法来创建循环，即跳转到循环开始时的标号： top: ... ... jmp top ;不断地循环 JMP 是无条件的，因此循环会无休止地进行下去，除非找到其他方法退岀循环。 Written by Visors all right reserved，powered by Gitbook本文档更新于： 2019-12-22 20:44 "},"5-2.html":{"url":"5-2.html","title":"5.2 条件转移、比较指令和if结构","keywords":"","body":"5.2 条件转移、比较指令和if结构 x86 指令集中没有明确的高级逻辑结构，但是可以通过比较和跳转的组合来实现它们。 执行一个条件语句需要两个步骤： 第一步，用 CMP、ADD 或 SUB 等操作来修改 CPU 状态标志位； 第二步，用条件跳转指令来测试标志位，并产生一个到新地址的分支。 CMP 指令 CMP 指令比较整数。字符代码也是整数，因此可以用 CMP 指令。 CMP（比较）指令执行从目的操作数中减去源操作数的隐含减法操作，并且不修改任何操作数： CMP destination, source 标志位 当实际的减法发生时，CMP 指令按照计算结果修改溢出、符号、零、进位、辅助进位和奇偶标志位。 如果比较的是两个无符号数，则零标志位和进位标志位表示的两个操作数之间的关系如右表所示： CMP结果 ZF CF 目的操作数 0 1 目的操作数 > 源操作数 0 0 目的操作数 = 源操作数 1 0 如果比较的是两个有符号数，则符号标志位、零标志位和溢出标志位表示的两个操作数之间的关系如右表所示： CMP结果 标志位 目的操作数 SF ≠ OF 目的操作数 > 源操作数 SF=OF 目的操作数 = 源操作数 ZF=1 CMP 指令是创建条件逻辑结构的重要工具。当在条件跳转指令中使用 CMP 时，汇编语言的执行结果就和 IF 语句一样。 条件转移指令 下表展示了基于零标志位、进位标志位、溢出标志位、奇偶标志位和符号标志位的跳转。 助记符 说明 标志位/寄存器 助记符 说明 标志位/寄存器 JZ 为零跳转 ZF=1 JNO 无溢出跳转 OF=0 JNZ 非零跳转 ZF=0 JS 有符号跳转 SF=1 JC 进位跳转 CF=1 JNS 无符号跳转 SF=0 JNC 无进位跳转 CF=0 JP 偶校验跳转 PF=1 JO 溢出跳转 OF=1 JNP 奇校验跳转 PF=0 相等性的比较 下表列出了基于相等性评估的跳转指令。有些情况下，进行比较的是两个操作数；其他情况下，则是基于 CX、ECX 或 RCX 的值进行跳转。表中符号 leftOp 和 rightOp 分别指的是 CMP 指令中的左（目的）操作数和右（源）操 作数： 助记符 说明 JE 相等跳转 (leftOp=rightOp) JNE 不相等跳转 (leftOp M rightOp) JCXZ CX=0 跳转 JECXZ ECX=0 跳转 JRCXZ RCX=0 跳转（64 位模式） 无符号数比较 基于无符号数比较的跳转如下表所示。操作数的名称反映了表达式中操作数的顺序（比如 leftOp 助记符 说明 助记符 说明 JA 大于跳转（若 leftOp > rightOp） JB 小于跳转（若 leftOp JNBE 不小于或等于跳转（与 JA 相同） JNAE 不大于或等于跳转（与 JB 相同） JAE 大于或等于跳转（若 leftOp ≥ rightOp） JBE 小于或等于跳转（若 leftOp ≤ rightOp） JNB 不小于跳转（与 JAE 相同） JNA 不大于跳转（与 JBE 相同） 有符号数比较 下表列岀了基于有符号数比较的跳转。下面的指令序列展示了两个有符号数值的比较： 助记符 说明 助记符 说明 JG 大于跳转（若 leftOp > rightOp） JL 小于跳转（若 leftOp JNLE 不小于或等于跳转（与 JG 相同） JNGE 不大于或等于跳转（与 JL 相同） JGE 大于或等于跳转（若 leftOp ≥ rightOp） JLE 小于或等于跳转（若 leftOp ≤ rightOp） JNL 不小于跳转（与 JGE 相同） JNG 不大于跳转（与 JLE 相同） 使用汇编语言实现if语句 IF 结构包含一个布尔表达式，其后有两个语句列表：一个是当表达式为真时执行，另一个是当表达式为假时执行： if( boolean-expression ) statement-list-1 else statement-list-2 结构中的 else 部分是可选的。在汇编语言中，则是用多个步骤来实现这种结构的。首先，对布尔表达式求值，这样一来某个 CPU 状态标志位会受到影响。然后，根据相关 CPU 状态标志位的值，构建一系列跳转把控制传递给两个语句列表。 【示例 1】下面的 C++ 代码中，如果 op1 等于 op2，则执行两条赋值语句： if( op1 = op2 ) { X = 1; Y = 2; } 在汇编语言中，这种 IF 语句转换为条件跳转和 CMP 指令。由于 op1 和 op2 都是内存操作数（变量），因此，在执行 CMP 之前，要将其中的一个操作数送入寄存器。 下面实现 IF 语句的程序是高效的，当逻辑表达式为真时，它允许代码“通过”直达两条期望被执行的 MOV 指令： mov eax, op1 cmp eax, op2 ; op1 == op2? jne L1 ; 否：跳过后续指令 mov X, 1 ; 是：X, Y 赋值 mov Y, 2 L1: 如果用 JE 来实现 == 运算符，生成的代码就没有那么紧凑了（6 条指令，而非 5 条指令）： mov eax, op1 cmp eax, op2 ; op1 == op2? je L1 ; 是：跳转到 L1 jmp L2 ; 否：跳过赋值语句 L1: mov X, 1 ; X, Y 赋值 mov Y, 2 L2: 从上面的例子可以看出，相同的条件结构在汇编语言中有多种实现方法。上面给出的编译代码示例只代表一种假想的编译器可能产生的结果。 Written by Visors all right reserved，powered by Gitbook本文档更新于： 2019-12-22 21:35 "},"5-3.html":{"url":"5-3.html","title":"5.3 循环结构的实现","keywords":"","body":"5.3 循环结构的实现 WHILE 循环在执行语句块之前先进行条件测试。只要循环条件一直为真，那么语句块就不断重复。下面是用 C++ 编写的循环： while( val1 用汇编语言实现这个结构时，可以很方便地改变循环条件，当条件为真时，跳转到 endwhile。假设 val1 和 val2 都是变量，那么在循环开始之前必须将其中的一个变量送入寄存器，并且还要在最后恢复该变量的值： mov eax, val1 ; 把变量复制到 EAX beginWhile: cmp eax, val2 ; 如果非 val1 在循环内部，EAX 是 val1 的代理（替代品），对 val1 的引用必须要通过 EAX。JNL 的使用意味着 val1 和 val2 是有符号整数。 当然这个beginWhile endWhile都是自己起的标号名字。 Written by Visors all right reserved，powered by Gitbook本文档更新于： 2019-12-24 13:29 "},"5-4.html":{"url":"5-4.html","title":"5.4 汇编语言中的for循环","keywords":"","body":"5.4 汇编语言中的for循环 利用loop实现循环。 loop destination 伪代码表示的loop指令执行以下动作： ecx-- if ecx==0 : break else : jmp to destination 那么我们很容易写出一个for循环，例如是1~50的循环 mov ecx, 50 forl: ;{循环体} loop forl Written by Visors all right reserved，powered by Gitbook本文档更新于： 2019-12-24 13:33 "},"5-5.html":{"url":"5-5.html","title":"5.5 数组","keywords":"","body":"5.5 数组 我们可以用 arrayName Type length DUP (init) 来初始化一个长度为length，初始值为init的每个元素内存为Type字节的数组arrayName。 回忆 C++ 知识，我们有指针、地址和下标的概念，汇编语言也差不多。 lea destination, source 可将source的地址取出存在destination中，destination通常是32位寄存器，source则是arrayName。 那么destination现在是不是就是 C++ 中的指针？ok，那我们来用指针访问数组内容。 [destination + index] index是偏移量，也就是字节差，对应到下标，如果数组类型是Byte，那么偏移量就是公差为1的等差数列，如果是Word，那就是2，以此类推。 我们可以使用 add destination, index 来移动指针。 如果对 C++ 掌握的不错，学起来是不是非常简单？ Written by Visors all right reserved，powered by Gitbook本文档更新于： 2019-12-24 13:45 "}}