{"./":{"url":"./","title":"前言","keywords":"","body":"Introduction 《80x86汇编语言与计算机体系结构》学习笔记 written by Visors QQ:416815311 Mail:visors@scuec.edu.cn 欢迎在评论区指出问题，讨论学术🤭 如果你的电脑上没有显示disqus，可以移步讨论区 Written by Visors all right reserved，powered by Gitbook本文档更新于： 2019-09-05 18:48 "},"1.html":{"url":"1.html","title":"1 计算机中数的表示","keywords":"","body":"1 计算机中数的表示 本章主要介绍了计算机的存储方式，以及数的表示和运算。是基础中的基础，后面的很多章节都基于这节的内容。 Written by Visors all right reserved，powered by Gitbook本文档更新于： 2019-09-16 23:43 "},"1-1.html":{"url":"1-1.html","title":"1.1 二进制和十六进制数","keywords":"","body":"1.1 二进制和十六进制数 本节给出了计算机存储中二进制数和十六进制数之间的关系。 日常生活中我们用十进制来表示数，逢十进一。 计算机由于其典型的开关式设计，无法直接采用十进制存储，用的是二进制01式的存储（0关1开）。 二进制权值与十进制不同： 11010=1∗104+1∗103+0∗102+1∗101+0∗10011010=1*10^4+1*10^3+0*10^2+1*10^1+0*10^011010=1∗10​4​​+1∗10​3​​+0∗10​2​​+1∗10​1​​+0∗10​0​​ 110102=1∗24+1∗23+0∗22+1∗21+0∗20=2611010_2=1*2^4+1*2^3+0*2^2+1*2^1+0*2^0=2611010​2​​=1∗2​4​​+1∗2​3​​+0∗2​2​​+1∗2​1​​+0∗2​0​​=26 究其根本原因是系数相同而权值不同。 同理十六进制即权值为16. 十进制 十六进制 二进制 0 0 0 1 1 1 2 2 10 3 3 11 4 4 100 5 5 101 6 6 110 7 7 111 8 8 1000 9 9 1001 10 A 1010 11 B 1010 12 C 1100 13 D 1101 14 E 1110 15 F 1111 可以发现，如果将不足4位的二进制数的前置空位补上0，那么可以认为每四位二进制数对应一个十六进制数。 同理八进制数可用三位二进制数表示，三位十六进制数可用四位八进制数表示。 进制转换高中数学讲过。 十进制转N进制——除N取余法 N进制转十进制——按位展开法 Written by Visors all right reserved，powered by Gitbook本文档更新于： 2019-09-02 14:23 "},"1-2.html":{"url":"1-2.html","title":"1.2 字符编码","keywords":"","body":"1.2 字符编码 计算机无法直接存储字符，故而用特定数值来表示各种字符，最常见的表示规则是美国信息交换标准代码ASCII，它建立了字符与数值间的映射关系。 ASCII码表 表中0016∼1F1600_{16}\\sim1F_{16}00​16​​∼1F​16​​比较特殊，他们不是常规意义上的字符（打印输出字符），他们是控制字符。例如特殊服务控制ESC、回车CR、换行LF等。 Written by Visors all right reserved，powered by Gitbook本文档更新于： 2019-09-02 16:57 "},"1-3.html":{"url":"1-3.html","title":"1.3 有符号整数的二进制补码表示","keywords":"","body":"1.3 有符号整数的二进制补码表示 前面小节已介绍过二进制和ASCII，如果要在计算机中表示数，可以对应的用到这两种表示方法： ASCII表示 把数字看成字符，拆成一个个字符存在一起 二进制表示 进制转换 这两种表示方法在表示时有两点问题值得注意： 表示数的有效位是有限的 如何表示负数并不明确 ASCII表示 常见ASCII码为0~127，正好可以用7位表示。8位1字节，附加位（左侧或最高位）设为0即可。 如果要表示负数，负号（减号）的ASCII为2D，用一位记下即可。 −817=2D 38 31 37-817=2D~38~31~37−817=2D 38 31 37 解决第一个问题的方法是固定字节长度，位数不足时补前导0. 也可以用长度可变的字节数，但须规定以非数字字符结尾（用以分割）。 二进制表示 将十进制转化为二进制存储。 解决第一个问题同样是定长补前导0，下面这个例子是2字节（16位）定长表示（1字节=8位 1字=16位）。 69710=10101110012=00000010101110012=02B916697_{10}=1010111001_2=0000001010111001_2=02B9_{16}697​10​​=1010111001​2​​=0000001010111001​2​​=02B9​16​​ 这样便可以很好的表示非负数和无符号数，但负号是符号不是数值，不能拆解在二进制表示中。 当然你也可以说负号ASCII码2D162D_{16}2D​16​​可以拆成1011012101101_2101101​2​​，但若真这样做，负号将会占用6位，考虑到整数的普遍性，我们在对每一个数存储时都要考虑其成为负数的可能性，那么每个数都要预留一个“负数位”，这样会造成巨大的空间浪费，是极其不成熟的。我们采用“二进制补码表示法”解决这个问题。 二进制补码表示 规定二进制数最左边一位为符号位。 01111111111111112=7FFF16=32767100111111111111111_2=7FFF_{16}=32767_{10}0111111111111111​2​​=7FFF​16​​=32767​10​​ 最左边的符号位被置为0，表示这个数是正数。 但这并不意味着负数的符号位为1，然后其他部分与之完全相同（这种表示方法叫做原码）。 表示负数惯用的做法是对其取补： 对于定长二进制数，用1后跟二进制位数个0表示的二进制数减去无符号部分。 下面这个例子展示了十进制负数取补的过程。 −7610=1000016−7610=1000016−004C16=FFB416-76_{10}=10000_{16}-76_{10}=10000_{16}-004C_{16}=FFB4_{16}−76​10​​=10000​16​​−76​10​​=10000​16​​−004C​16​​=FFB4​16​​ 减法部分参照竖式运算 减去无符号部分可以视为减绝对值 单字长为16位，所以用17位100000000000000002=1000016=21610000000000000000_2=10000_{16}=2^{16}10000000000000000​2​​=10000​16​​=2​16​​减无符号部分取补。我们称FFB4FFB4FFB4为−76-76−76的补码。非负数的补码只需在前面加前导0占位。 补码的基本性质 补码表示数的范围 由于我们规定了符号位，所以以单字长二进制数为例，最大正整数为0111111111111111=1000000000000000−1=215−10111111111111111=1000000000000000-1=2^{15}-10111111111111111=1000000000000000−1=2​15​​−1 可以推广一下，即对于NNN位二进制数，最大正整数为2N−1−12^{N-1}-12​N−1​​−1. 自然，我们也想知道最小负整数，我们可以从将二进制补码还原为负数这一角度入手。 根据符号位的定义，第一位为1时为负数，换言之，负数的补码范围为1000000000000000∼11111111111111111000000000000000\\sim11111111111111111000000000000000∼1111111111111111 分析原操作，设该负数为−x-x−x，长度为NNN位（其中有一个符号位，故有效位数实际上是N−1N-1N−1），补码为yyy，那么有2N−x=y2^N-x=y2​N​​−x=y，在yyy已知的情况下： 2N−x=y2^N-x=y2​N​​−x=y y−2N=−xy-2^N=-xy−2​N​​=−x x=2N−yx=2^N-yx=2​N​​−y 由负数补码范围知2N−1≤y2N2^{N-1}\\leq y2​N−1​​≤y2​N​​，那么yyy越小，2N−y2^N-y2​N​​−y就越大，xxx就越大，−x-x−x就越小 即−x-x−x在y=2N−1y=2^{N-1}y=2​N−1​​时取得最小值，最小为−2N−1-2^{N-1}−2​N−1​​ 也就是说 NNN位表示的数的范围为−2N−1∼2N−1−1-2^{N-1}\\sim2^{N-1}-1−2​N−1​​∼2​N−1​​−1 补码的还原 2N−1−x=y2^{N-1}-x=y2​N−1​​−x=y 2N−1−y=2N−1−(2N−1−x)=x2^{N-1}-y=2^{N-1}-(2^{N-1}-x)=x2​N−1​​−y=2​N−1​​−(2​N−1​​−x)=x 也就是说，对一个数二次取补会得到它的本身。 但需要注意，取补与表示为补码为不同的操作，事实上： 如果原数是一个非负数，当我们知道它的补码表示（等于原数）时，再表示出这个补码的补码，仍然是原数，因为这个过程中数都为非负数，非负数的补码操作只是补足前导0. 如果原数是一个负数，当我们知道它的补码表示（对无符号部分求补）时，再表示出这个补码的补码，会得到原数的无符号部分。 所以还原补码的正确操作应该是先判断补码的符号，确定原数是不是负数后，再对照上面的规则求出。 一个简单的判断符号的方法是，如果这个补码大于该长度二进制数表示的一半，那么原数是负数；反之为非负数。对于字长的二进制补码，”一半“指的是8000；对于字节的二进制补码，”一半“指的是80. 由此结论，我们还可以简化前面补码表示数的范围的推理过程。 取补的另一种方法 由于二进制太长书写不变，此前我们都是用十六进制缩写二进制，这种表示下，做十六进制减法效率上很高。实际上，我们还有另一种取补方法： 原码非符号位按位取反+1 前面的例子我们已经知道−76-76−76表示成字节的二进制补码是B416B4_{16}B4​16​​ 我们尝试一下按位取反 按位取反既是对每位取反，1成0，0成1.这里接用很多高级语言按位取反运算符~表示 −76=110011002-76=11001100_2−76=11001100​2​​ ∼76=101100112\\sim76=10110011_2∼76=10110011​2​​ 再加上1，得到的结果便是 101101002=B41610110100_2=B4_{16}10110100​2​​=B4​16​​ 与前面的结果一致。 Written by Visors all right reserved，powered by Gitbook本文档更新于： 2019-09-02 23:02 "},"1-4.html":{"url":"1-4.html","title":"1.4 二进制补码数的加减法","keywords":"","body":"1.4 二进制补码数的加减法 从本节开始，我将摒弃之前过细描述的臃肿感，略过人人皆知的定义，采用更加精炼的语言，减少在书本重现上浪费的时间，转而让我从每日的忙碌中解放出来，可以更细心的阅读中英教材，专注书本知识的注意点，以及我个人学习经验对之的拓展，真正使复杂的问题简单化，使抽象的东西形象化。 两种重要情况 有符号数用二进制补码形式表示，但二进制补码数也可看作无符号数，所以有符号数相加并不完全等于补码数相加。 在二进制补码数的加减法中，我们关注计算中的两种情况： 向符号位的进位 符号位进位输出 向符号位的进位 举一例说明： 0100 1000 0011 1111 +0110 0100 0101 1010 =1010 1100 1001 1001 可以看到，当483F483F483F与645A645A645A相加后，得到的结果AC99AC99AC99超过了我们说的字长的二进制补码的分界线800080008000，抑或是说符号位由000变为111。我们称这种情况为向符号位的进位。 符号位进位输出 再举一例： ​ 1110 1001 1111 1111 +1000 1100 1111 0000 =10111 0110 1110 1111 可以看到E9FFE9FFE9FF和8CF08CF08CF0相加后，得到的结果176EF176EF176EF超过了字长的存储位数限制。实际计算机存储中，该结果会被强行截断成字长（截去超出范围）。在这个例子中，实际结果为76EF76EF76EF。 溢出 当加法运算中发生溢出overflow时，得到的结果存在错误。我们可以人为判断溢出是否发生，计算机硬件也可以判断。判断溢出与否的方法就跟上述两种情况有关。事实上，溢出并不如其字面上那样，“是单纯的超过数据范围”，而应该是如下情况： 向符号位的进位 符号位进位输出 溢出 0 0 0 0 1 1 1 0 1 1 1 0 这张类似真值表的情况表给出了判断溢出是否发生的简单方法。 二进制减法 将减法看作加上对应数的负数，即加负数的补码即可。 Written by Visors all right reserved，powered by Gitbook本文档更新于： 2019-09-16 21:12 "},"2.html":{"url":"2.html","title":"2 计算机系统的组成","keywords":"","body":"2 计算机系统的组成 本章更进一步地介绍了一些计算机导论中介绍过的硬件知识，但存在不少未提到的重点内容。汇编以硬件层面为重，我们有必要深入理解这一部分内容。这些内容将以杂谈的形式呈现在文末。 教材以80386或更高的处理器以及32位操作系统为基准。 Written by Visors all right reserved，powered by Gitbook本文档更新于： 2019-09-16 23:55 "},"2-1.html":{"url":"2-1.html","title":"2.1 微机硬件：存储器","keywords":"","body":"2.1 微机硬件：存储器 两种存储模式 平面存储模式 又称线性内存模型，在这种模式下，应用程序看到的内存是一个单独的连续地址（本书为32位地址）空间。CPU可以直接（且线性）寻址所有可利用的内存位置，无需诉诸任何内存分段或分页机制，平面存储器模式利用到了虚拟内存技术。 分段存储模式 在该模式中，PC存储器被看做是段的集合，每个段64KB。其中： 64KB=64×1024Byte=216Byte64KB=64\\times 1024Byte=2^{16}Byte64KB=64×1024Byte=2​16​​Byte 即每个段有可用2162^{16}2​16​​个可用空间，我们可以用4位十六进制数为之编号，称为偏移量。 那么32位空间可被分成的段数即为 232÷216=2162^{32}\\div 2^{16}=2^{16}2​32​​÷2​16​​=2​16​​ 同理我们也可以对段编号，对应4位十六进制编号，称为段号。 由此任意存储单元地址可被表示为 段号:偏移量 喜闻乐见吐槽环节 平面存储模式的英文应为flat memory model，书中漏了model，分段存储模式也是。 168Byte=232Byte=4GB16^8Byte=2^{32}Byte=4GB16​8​​Byte=2​32​​Byte=4GB，这也是为什么32位系统最多只能装4G内存的原因。现实生活中随着各种应用、游戏占用内存提升，4G内存完全不能满足需求，所以它们逐渐抛弃32位软件的开发，只支持64位。前几年很多3A大作出来的时候，身边很多人都说自己电脑32位玩不了。快看看你Steam库存的游戏配置需求。不过现在64位电脑在新用户中基本上普及了。 Written by Visors all right reserved，powered by Gitbook本文档更新于： 2019-09-17 00:34 "},"2-2.html":{"url":"2-2.html","title":"2.2 微机的硬件：CPU","keywords":"","body":"2.2 微机的硬件：CPU 这节第一次出现了汇编指令。 寄存器 寄存器名前加E是32位寄存器 数据寄存器 数据寄存器 低位字0~15 低位字节0~7 高位字节8~15 EAX AX AL AH EBX BX BL BH ECX CX CL CH EDX DX DL DH 通用寄存器 索引寄存器ESI、EDI，SI代表索引源，DI代表目的索引 栈指针ESP 基址指针寄存器EBP 段寄存器 CS、DS、ES、FS、GS、SS 指令寄存器EIP 指令指针，编程人员不能直接访问。用来存放当前指令的下一条指令的地址。CPU该执行哪条指令就是通过IP来指示的。 标志寄存器EFLAGS 好好看书🙃 Written by Visors all right reserved，powered by Gitbook本文档更新于： 2019-09-17 01:10 "},"2-3.html":{"url":"2-3.html","title":"2.3 微机硬件：输入/输出设备","keywords":"","body":"2.3 微机硬件：输入/输出设备 水过😏 Written by Visors all right reserved，powered by Gitbook本文档更新于： 2019-09-26 01:11 "},"2-4.html":{"url":"2-4.html","title":"2.4 PC软件","keywords":"","body":"2.4 PC软件 操作系统 程序运行在对应的操作系统上。操作系统界面有命令行界面（尝试Win+R运行“cmd”），也有图形用户界面（你现在看到的）。 文本编辑器 VimVimVim d=\\====(￣▽￣*)b 语言翻译器和链接器 千万不要IDE、编译器、文本编辑器傻傻分不清啊 解释器：执行程序的程序 编译器：把特定语言源代码翻译成CPU可执行指令 链接器：链接不同代码，包含在编译器中 调试器：你的写bugDebug利器 汇编器：类似编译器，只不过翻译的是汇编语言 翻译器：解释器、编译器、汇编器的统称 集成开发环境：IDE，包含上述若干工具的程序，比如Visual Studio。 Visual Studio Code是文本编辑器 （严肃脸）（认真脸） Written by Visors all right reserved，powered by Gitbook本文档更新于： 2019-09-17 01:25 "},"3.html":{"url":"3.html","title":"3 汇编语言的要素","keywords":"","body":"3 汇编语言的要素 Written by Visors all right reserved，powered by Gitbook本文档更新于： 2019-09-24 10:59 "},"3-1.html":{"url":"3-1.html","title":"3.1 汇编语句","keywords":"","body":"3.1 汇编语句 分行 当单行代码过长时，会严重影响程序的可阅读性。拿python举个例子： print(3) print(“Ceeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeb!”) print(6) MASM允许在每行末尾使用backslash()将不长于512个字符的单句拆成多行。 注释 使用semicolon(;)将其至行末的代码设为注释。 可用backslash将注释分行。 三种语句 汇编语言语句主要分为三种： 指令性语句instruction：通过汇编器翻译成目标代码 指示性语句directive：告诉汇编器做某种操作 宏语句marco：一系列语句的缩写 一条语句通常可以表示为下面的形式： (名字:) 助记符 操作数 ;注释 WaitWaitWait，我怎么又开始废话多了 总之，这章有点蠢，提了很多东西又没讲明白，看了上面直接看下章吧。 Written by Visors all right reserved，powered by Gitbook本文档更新于： 2019-09-26 00:38 "},"3-2.html":{"url":"3-2.html","title":"3.2 一个完整的实例","keywords":"","body":"3.2 一个完整的实例 代码一下丢出一堆莫名其妙的东西，虽说跟我们初学Hello World一样，但有些内容甚至整本书直接不解释。话不多说直接开吐槽。 NEAR32是距离的一种，类似的还有near,far,near16,far16,far32，在win32中只有平坦的段flat无所谓距离，所以这个参数通常忽略。 stdcall是语言类型，类似的还有c,syscall,basic,fortran,pascal，如果忽略，则使用程序头部.model定义的值。 注意区分EQU与MOV，前者类似定义符号常量，后者类似赋值。 .DATA段像极了Pascal等语言，变量要统一声明在特定部分。 prompt1 BYTE \"Enter first number: \",0这句话，书中说是为数字0保留了一个字节长度。请这样想： 多个操作数中间以逗号分隔 字符串是多个字符操作数的集中表示 数字0准确的说表示的是空字符00 空字符作用类似C字符串结尾的隐式'\\0' Written by Visors all right reserved，powered by Gitbook本文档更新于： 2019-09-26 01:03 "},"3-3.html":{"url":"3-3.html","title":"3.3 程序的汇编、链接和运行","keywords":"","body":"3.3 程序的汇编、链接和运行 了解下windbg使用过程 Written by Visors all right reserved，powered by Gitbook本文档更新于： 2019-09-26 01:11 "},"3-4.html":{"url":"3-4.html","title":"3.4 汇编器清单文件","keywords":"","body":"3.4 汇编器清单文件 Written by Visors all right reserved，powered by Gitbook本文档更新于： 2019-09-24 10:59 "},"3-5.html":{"url":"3-5.html","title":"3.5 常数操作数","keywords":"","body":"3.5 常数操作数 Written by Visors all right reserved，powered by Gitbook本文档更新于： 2019-09-24 10:59 "},"3-6.html":{"url":"3-6.html","title":"3.6 指令中的操作数","keywords":"","body":"3.6 指令中的操作数 Written by Visors all right reserved，powered by Gitbook本文档更新于： 2019-09-24 10:59 "},"3-7.html":{"url":"3-7.html","title":"3.7 使用IO.H中宏的输入/输出","keywords":"","body":"3.7 使用IO.H中宏的输入/输出 Written by Visors all right reserved，powered by Gitbook本文档更新于： 2019-09-24 10:59 "}}