# 6.1 80x86堆栈

## 堆栈概念

### 堆栈 stack

如下图所示，如果把 10 个盘子垒起来，其结果就称为堆栈。虽然有可能从这个堆栈的中间移出一个盘子，但是，更普遍的是从顶端移除。新的盘子可以叠加到堆栈顶部，但不能加在底部或中部。



![盘子构成的堆栈](http://c.biancheng.net/uploads/allimg/190505/4-1Z50514301TQ.gif)


堆栈数据结构（stack data structure）的原理与盘子堆栈相同：新值添加到栈顶，删除值也在栈顶移除。通常，对各种编程应用来说，堆栈都是有用的结构，并且它们也容易用面向对象的编程方法来实现。

如果大家已经学习过使用数据结构的编程课程，那么就应该已经用过堆栈抽象数据类型（stack abstract data type）。

堆栈也被称为 LIFO 结构（后进先出，Last-In First-Out），其原因是，最后进入堆栈的值也是第一个出堆栈的值。

### 运行时堆栈

运行时堆栈是内存数组，CPU 用 ESP（扩展堆栈指针，extended stack pointer）寄存器对其进行直接管理，该寄存器被称为堆栈指针寄存器（stack pointer register）。

32位模式下，ESP 寄存器存放的是堆栈中某个位置的 32 位偏移量。ESP 基本上不会直接被程序员控制，反之，它是用 CALL、RET、PUSH 和 POP 等指令间接进行修改。

ESP 总是指向添加，或压入（pushed）到栈顶的最后一个数值。为了便于说明，假设现有一个堆栈，内含一个数值。如下图所示，ESP 的内容是十六进制数 0000 1000，即刚压入堆栈数值（0000 0006）的偏移量。在图中，当堆栈指针数值减少时，栈顶也随之下移。



![包含一个值得堆栈](http://c.biancheng.net/uploads/allimg/190505/4-1Z505154RRX.gif)


上图中，每个堆栈位置都是32位长，这 是32位模式下运行程序的情形。

运行时堆栈工作于系统层，处理子程序调用。堆栈 ADT 是编程结构，通常用高级编程语言编写，如 C++ 或 Java。它用于实现基于后进先出操作的算法。

### 入栈操作

32 位入栈操作把栈顶指针减 4，再将数值复制到栈顶指针指向的堆栈位置。下图展示了把 0000 00A5 压入堆栈的结果，堆栈中已经有一个数值（0000 0006）。注意，ESP 寄存器总是指向最后压入堆栈的数据项。



![将整数压入堆栈](http://c.biancheng.net/uploads/allimg/190505/4-1Z505154Zb64.gif)


上图中显示的堆栈顺序与之前示例给出的盘堆栈顺序相反，这是因为运行时堆栈在内存中是向下生长的，即从高地址向低地址扩展。入栈之前， ESP=0000 1000h；入栈之后，ESP=0000 0FFCh。下图显示了同一个堆栈总共压入 4 个整数之后的情况。



![压入数值00000001和00000002的堆栈](http://c.biancheng.net/uploads/allimg/190505/4-1Z505154942144.gif)

### 出栈操作

出栈操作从堆栈删除数据。数值弹岀堆栈后，栈顶指针增加（按堆栈元素大小），指向堆栈中下一个最高位置。下图展示了数值 0000 0002 弹出前后的堆栈情况。



![从运行时堆栈弹出一个数值](http://c.biancheng.net/uploads/allimg/190505/4-1Z50515503c32.gif)


ESP 之下的堆栈域在逻辑上是空白的，当前程序下一次执行任何数值入栈操作指令都可以覆盖这个区域。

### 堆栈应用

运行时堆栈在程序中有一些重要用途：

- 当寄存器用于多个目的时，堆栈可以作为寄存器的一个方便的临时保存区。在寄存器被修改后，还可以恢复其初始值。
- 执行 CALL 指令时，CPU 在堆栈中保存当前过程的返回地址。
- 调用过程时，输入数值也被称为参数，通过将其压入堆栈实现参数传递。
- 堆栈也为过程局部变量提供了临时存储区域。

## 堆栈指令

### 分配堆栈空间

栈中每一个元素都占用内存，要规定堆栈的内存大小，使用

```.stack byteNum```

通常我们分配 4K 堆栈：

```.stack 4096```

----------------------------------

汇编里把一段内存空间定义为一个栈，栈总是先进后出，栈的最大空间为 64K。由于 "栈" 是由高到低使用的，所以新压入的数据的位置更低，ESP 中的指针将一直指向这个新位置，所以 ESP 中的地址数据是动态的。

### PUSH 指令

PUSH 指令首先减少 ESP 的值，再将源操作数复制到堆栈。操作数是 16 位的，则 ESP 减 2，操作数是 32 位的，则 ESP 减 4。PUSH 指令有 3 种格式：

```assembly
PUSH reg/mem16
PUSH reg/mem32
PUSH inm32
```

如果操作数类型不明确，可用 PUSHW 和 PUSHD 分别指定字或双字操作数。

### POP指令

POP 指令首先把 ESP 指向的堆栈元素内容复制到一个 16 位或 32 位目的操作数中，再增加 ESP 的值。如果操作数是 16 位的，ESP 加 2，如果操作数是 32 位的，ESP 加 4：

```assembly
POP reg/mem16
POP reg/mem32
```

### PUSHF POPF

PUSHF(PUSHFD)/POPF(POPFD)是（扩展）标志寄存器的入栈/出栈指令。

不能用 MOV 指令把标志寄存器内容复制给一个变量，因此，PUSHFD 可能就是保存标志位的最佳途径。有些时候保存标志寄存器的副本是非常有用的，这样之后就可以恢复标志寄存器原来的值。

**操作结果影响标志寄存器**。

### PUSHAD，PUSHA，POPAD 和 POPA

PUSHAD 指令按照 EAX、ECX、EDX、EBX、ESP（执行 PUSHAD 之前的值）、EBP、ESI 和 EDI 的顺序，将所有 32 位通用寄存器压入堆栈。

POPAD 指令按照相反顺序将同样的寄存器弹出堆栈。

与之相似，PUSHA 指令按序（AX、CX、DX、BX、SP、BP、SI 和 DI）将 16 位通用寄存器压入堆栈。

POPA 指令按照相反顺序将同样的寄存器弹出堆栈。在 16 位模式下，只能使用 PUSHA 和 POPA 指令。

如果编写的过程会修改 32 位寄存器的值，则在过程开始时使用 PUSHAD 指令，在结束时使用 POPAD 指令，以此保存和恢复寄存器的内容。

### 利用堆栈实现 xchg

```assembly
push eax
mov eax, ebx
pop ebx
```

